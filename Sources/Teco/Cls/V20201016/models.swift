//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

@_exported import struct Foundation.Date
import TecoDateHelpers

extension Cls {
    /// 告警多维分析一些配置信息
    public struct AlarmAnalysisConfig: TCInputModel {
        /// 键
        public let key: String

        /// 值
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// 告警策略描述
    public struct AlarmInfo: TCOutputModel {
        /// 告警策略名称。
        public let name: String

        /// 监控对象列表。
        public let alarmTargets: [AlarmTargetInfo]

        /// 监控任务运行时间点。
        public let monitorTime: MonitorTime

        /// 触发条件。
        public let condition: String

        /// 持续周期。持续满足触发条件TriggerCount个周期后，再进行告警；最小值为1，最大值为10。
        public let triggerCount: Int64

        /// 告警重复的周期。单位是min。取值范围是0~1440。
        public let alarmPeriod: Int64

        /// 关联的告警通知模板列表。
        public let alarmNoticeIds: [String]

        /// 开启状态。
        public let status: Bool

        /// 告警策略ID。
        public let alarmId: String

        /// 创建时间。
        public let createTime: String

        /// 最近更新时间。
        public let updateTime: String

        /// 自定义通知模板
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let messageTemplate: String?

        /// 自定义回调模板
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let callBack: CallBackInfo?

        /// 多维分析设置
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let analysis: [AnalysisDimensional]?

        enum CodingKeys: String, CodingKey {
            case name = "Name"
            case alarmTargets = "AlarmTargets"
            case monitorTime = "MonitorTime"
            case condition = "Condition"
            case triggerCount = "TriggerCount"
            case alarmPeriod = "AlarmPeriod"
            case alarmNoticeIds = "AlarmNoticeIds"
            case status = "Status"
            case alarmId = "AlarmId"
            case createTime = "CreateTime"
            case updateTime = "UpdateTime"
            case messageTemplate = "MessageTemplate"
            case callBack = "CallBack"
            case analysis = "Analysis"
        }
    }

    /// 告警通知模板类型
    public struct AlarmNotice: TCOutputModel {
        /// 告警通知模板名称。
        public let name: String

        /// 告警模板的类型。可选值：
        /// <br><li> Trigger - 告警触发
        /// <br><li> Recovery - 告警恢复
        /// <br><li> All - 告警触发和告警恢复
        public let type: String

        /// 告警通知模板接收者信息。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let noticeReceivers: [NoticeReceiver]?

        /// 告警通知模板回调信息。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let webCallbacks: [WebCallback]?

        /// 告警通知模板ID。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let alarmNoticeId: String?

        /// 创建时间。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let createTime: String?

        /// 最近更新时间。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let updateTime: String?

        enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case noticeReceivers = "NoticeReceivers"
            case webCallbacks = "WebCallbacks"
            case alarmNoticeId = "AlarmNoticeId"
            case createTime = "CreateTime"
            case updateTime = "UpdateTime"
        }
    }

    /// 告警对象
    public struct AlarmTarget: TCInputModel {
        /// 日志主题ID。
        public let topicId: String

        /// 查询语句。
        public let query: String

        /// 告警对象序号；从1开始递增。
        public let number: Int64

        /// 查询范围起始时间相对于告警执行时间的偏移，单位为分钟，取值为非正，最大值为0，最小值为-1440。
        public let startTimeOffset: Int64

        /// 查询范围终止时间相对于告警执行时间的偏移，单位为分钟，取值为非正，须大于StartTimeOffset，最大值为0，最小值为-1440。
        public let endTimeOffset: Int64

        /// 日志集ID。
        public let logsetId: String

        public init(topicId: String, query: String, number: Int64, startTimeOffset: Int64, endTimeOffset: Int64, logsetId: String) {
            self.topicId = topicId
            self.query = query
            self.number = number
            self.startTimeOffset = startTimeOffset
            self.endTimeOffset = endTimeOffset
            self.logsetId = logsetId
        }

        enum CodingKeys: String, CodingKey {
            case topicId = "TopicId"
            case query = "Query"
            case number = "Number"
            case startTimeOffset = "StartTimeOffset"
            case endTimeOffset = "EndTimeOffset"
            case logsetId = "LogsetId"
        }
    }

    /// 告警对象
    public struct AlarmTargetInfo: TCOutputModel {
        /// 日志集ID。
        public let logsetId: String

        /// 日志集名称。
        public let logsetName: String

        /// 日志主题ID。
        public let topicId: String

        /// 日志主题名称。
        public let topicName: String

        /// 查询语句。
        public let query: String

        /// 告警对象序号。
        public let number: Int64

        /// 查询范围起始时间相对于告警执行时间的偏移，单位为分钟，取值为非正，最大值为0，最小值为-1440。
        public let startTimeOffset: Int64

        /// 查询范围终止时间相对于告警执行时间的偏移，单位为分钟，取值为非正，须大于StartTimeOffset，最大值为0，最小值为-1440。
        public let endTimeOffset: Int64

        enum CodingKeys: String, CodingKey {
            case logsetId = "LogsetId"
            case logsetName = "LogsetName"
            case topicId = "TopicId"
            case topicName = "TopicName"
            case query = "Query"
            case number = "Number"
            case startTimeOffset = "StartTimeOffset"
            case endTimeOffset = "EndTimeOffset"
        }
    }

    /// 多维分析的分析维度
    public struct AnalysisDimensional: TCInputModel {
        /// 分析名称
        public let name: String

        /// 分析类型：query，field ，original
        public let type: String

        /// 分析内容
        public let content: String

        /// 配置
        public let configInfo: [AlarmAnalysisConfig]?

        public init(name: String, type: String, content: String, configInfo: [AlarmAnalysisConfig]? = nil) {
            self.name = name
            self.type = type
            self.content = content
            self.configInfo = configInfo
        }

        enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case content = "Content"
            case configInfo = "ConfigInfo"
        }
    }

    /// 回调配置
    public struct CallBackInfo: TCInputModel, TCOutputModel {
        /// 回调时的Body
        public let body: String

        /// 回调时的Headers
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let headers: [String]?

        public init(body: String, headers: [String]? = nil) {
            self.body = body
            self.headers = headers
        }

        enum CodingKeys: String, CodingKey {
            case body = "Body"
            case headers = "Headers"
        }
    }

    /// CKafka的描述-需要投递到的kafka信息
    public struct Ckafka: TCInputModel, TCOutputModel {
        /// Ckafka 的 Vip
        public let vip: String

        /// Ckafka 的 Vport
        public let vport: String

        /// Ckafka 的 InstanceId
        public let instanceId: String

        /// Ckafka 的 InstanceName
        public let instanceName: String

        /// Ckafka 的 TopicId
        public let topicId: String

        /// Ckafka 的 TopicName
        public let topicName: String

        public init(vip: String, vport: String, instanceId: String, instanceName: String, topicId: String, topicName: String) {
            self.vip = vip
            self.vport = vport
            self.instanceId = instanceId
            self.instanceName = instanceName
            self.topicId = topicId
            self.topicName = topicName
        }

        enum CodingKeys: String, CodingKey {
            case vip = "Vip"
            case vport = "Vport"
            case instanceId = "InstanceId"
            case instanceName = "InstanceName"
            case topicId = "TopicId"
            case topicName = "TopicName"
        }
    }

    /// 日志分析的列属性
    public struct Column: TCOutputModel {
        /// 列的名字
        public let name: String?

        /// 列的属性
        public let type: String?

        enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    /// 投递日志的压缩配置
    public struct CompressInfo: TCInputModel, TCOutputModel {
        /// 压缩格式，支持gzip、lzop、snappy和none不压缩
        public let format: String

        public init(format: String) {
            self.format = format
        }

        enum CodingKeys: String, CodingKey {
            case format = "Format"
        }
    }

    /// 特殊采集规则配置信息
    public struct ConfigExtraInfo: TCOutputModel {
        /// 采集规则扩展配置ID
        public let configExtraId: String

        /// 采集规则名称
        public let name: String

        /// 日志主题ID
        public let topicId: String

        /// 类型：container_stdout、container_file、host_file
        public let type: String

        /// 节点文件配置信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let hostFile: HostFileInfo?

        /// 容器文件路径信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let containerFile: ContainerFileInfo?

        /// 容器标准输出信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let containerStdout: ContainerStdoutInfo?

        /// 日志格式化方式
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logFormat: String?

        /// 采集的日志类型，json_log代表json格式日志，delimiter_log代表分隔符格式日志，minimalist_log代表极简日志，multiline_log代表多行日志，fullregex_log代表完整正则，默认为minimalist_log
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logType: String?

        /// 提取规则，如果设置了ExtractRule，则必须设置LogType
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let extractRule: ExtractRuleInfo?

        /// 采集黑名单路径列表
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let excludePaths: [ExcludePathInfo]?

        /// 更新时间
        public let updateTime: String

        /// 创建时间
        public let createTime: String

        /// 用户自定义解析字符串
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let userDefineRule: String?

        /// 机器组ID
        public let groupId: String

        /// 自建采集配置标
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let configFlag: String?

        /// 日志集ID
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logsetId: String?

        /// 日志集name
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logsetName: String?

        /// 日志主题name
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let topicName: String?

        enum CodingKeys: String, CodingKey {
            case configExtraId = "ConfigExtraId"
            case name = "Name"
            case topicId = "TopicId"
            case type = "Type"
            case hostFile = "HostFile"
            case containerFile = "ContainerFile"
            case containerStdout = "ContainerStdout"
            case logFormat = "LogFormat"
            case logType = "LogType"
            case extractRule = "ExtractRule"
            case excludePaths = "ExcludePaths"
            case updateTime = "UpdateTime"
            case createTime = "CreateTime"
            case userDefineRule = "UserDefineRule"
            case groupId = "GroupId"
            case configFlag = "ConfigFlag"
            case logsetId = "LogsetId"
            case logsetName = "LogsetName"
            case topicName = "TopicName"
        }
    }

    /// 采集规则配置信息
    public struct ConfigInfo: TCOutputModel {
        /// 采集规则配置ID
        public let configId: String

        /// 采集规则配置名称
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let name: String?

        /// 日志格式化方式
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logFormat: String?

        /// 日志采集路径
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let path: String?

        /// 采集的日志类型，json_log代表json格式日志，delimiter_log代表分隔符格式日志，minimalist_log代表极简日志，multiline_log代表多行日志，fullregex_log代表完整正则，默认为minimalist_log
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logType: String?

        /// 提取规则，如果设置了ExtractRule，则必须设置LogType
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let extractRule: ExtractRuleInfo?

        /// 采集黑名单路径列表
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let excludePaths: [ExcludePathInfo]?

        /// 采集配置所属日志主题ID即TopicId
        public let output: String

        /// 更新时间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var updateTime: Date?

        /// 创建时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var createTime: Date

        /// 用户自定义解析字符串
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let userDefineRule: String?

        enum CodingKeys: String, CodingKey {
            case configId = "ConfigId"
            case name = "Name"
            case logFormat = "LogFormat"
            case path = "Path"
            case logType = "LogType"
            case extractRule = "ExtractRule"
            case excludePaths = "ExcludePaths"
            case output = "Output"
            case updateTime = "UpdateTime"
            case createTime = "CreateTime"
            case userDefineRule = "UserDefineRule"
        }
    }

    /// 投递任务出入参 Content
    public struct ConsumerContent: TCInputModel, TCOutputModel {
        /// 是否投递 TAG 信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let enableTag: Bool?

        /// 需要投递的元数据列表，目前仅支持：\_\_SOURCE\_\_，\_\_FILENAME\_\_，\_\_TIMESTAMP\_\_，\_\_HOSTNAME\_\_和\_\_PKGID\_\_
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let metaFields: [String]?

        /// 当EnableTag为true时，必须填写TagJsonNotTiled字段，TagJsonNotTiled用于标识tag信息是否json平铺，TagJsonNotTiled为true时不平铺，false时平铺
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let tagJsonNotTiled: Bool?

        /// 投递时间戳精度，可选项 [1:秒；2:毫秒] ，默认是秒
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let timestampAccuracy: Int64?

        public init(enableTag: Bool, metaFields: [String], tagJsonNotTiled: Bool? = nil, timestampAccuracy: Int64? = nil) {
            self.enableTag = enableTag
            self.metaFields = metaFields
            self.tagJsonNotTiled = tagJsonNotTiled
            self.timestampAccuracy = timestampAccuracy
        }

        enum CodingKeys: String, CodingKey {
            case enableTag = "EnableTag"
            case metaFields = "MetaFields"
            case tagJsonNotTiled = "TagJsonNotTiled"
            case timestampAccuracy = "TimestampAccuracy"
        }
    }

    /// 自建k8s-容器文件路径信息
    public struct ContainerFileInfo: TCInputModel, TCOutputModel {
        /// namespace可以多个，用分隔号分割,例如A,B
        public let namespace: String

        /// 容器名称
        public let container: String

        /// 日志文件夹
        public let logPath: String

        /// 日志名称
        public let filePattern: String

        /// pod标签信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let includeLabels: [String]?

        /// 工作负载信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let workLoad: ContainerWorkLoadInfo?

        /// 需要排除的namespace可以多个，用分隔号分割,例如A,B
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let excludeNamespace: String?

        /// 需要排除的pod标签信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let excludeLabels: [String]?

        public init(namespace: String, container: String, logPath: String, filePattern: String, includeLabels: [String]? = nil, workLoad: ContainerWorkLoadInfo? = nil, excludeNamespace: String? = nil, excludeLabels: [String]? = nil) {
            self.namespace = namespace
            self.container = container
            self.logPath = logPath
            self.filePattern = filePattern
            self.includeLabels = includeLabels
            self.workLoad = workLoad
            self.excludeNamespace = excludeNamespace
            self.excludeLabels = excludeLabels
        }

        enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case container = "Container"
            case logPath = "LogPath"
            case filePattern = "FilePattern"
            case includeLabels = "IncludeLabels"
            case workLoad = "WorkLoad"
            case excludeNamespace = "ExcludeNamespace"
            case excludeLabels = "ExcludeLabels"
        }
    }

    /// 自建k8s-容器标准输出信息
    public struct ContainerStdoutInfo: TCInputModel, TCOutputModel {
        /// 是否所有容器
        public let allContainers: Bool

        /// container为空表所有的，不为空采集指定的容器
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let container: String?

        /// namespace可以多个，用分隔号分割,例如A,B；为空或者没有这个字段，表示所有namespace
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let namespace: String?

        /// pod标签信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let includeLabels: [String]?

        /// 工作负载信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let workLoads: [ContainerWorkLoadInfo]?

        /// 需要排除的namespace可以多个，用分隔号分割,例如A,B
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let excludeNamespace: String?

        /// 需要排除的pod标签信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let excludeLabels: [String]?

        public init(allContainers: Bool, container: String? = nil, namespace: String? = nil, includeLabels: [String]? = nil, workLoads: [ContainerWorkLoadInfo]? = nil, excludeNamespace: String? = nil, excludeLabels: [String]? = nil) {
            self.allContainers = allContainers
            self.container = container
            self.namespace = namespace
            self.includeLabels = includeLabels
            self.workLoads = workLoads
            self.excludeNamespace = excludeNamespace
            self.excludeLabels = excludeLabels
        }

        enum CodingKeys: String, CodingKey {
            case allContainers = "AllContainers"
            case container = "Container"
            case namespace = "Namespace"
            case includeLabels = "IncludeLabels"
            case workLoads = "WorkLoads"
            case excludeNamespace = "ExcludeNamespace"
            case excludeLabels = "ExcludeLabels"
        }
    }

    /// 自建k8s-工作负载信息
    public struct ContainerWorkLoadInfo: TCInputModel, TCOutputModel {
        /// 工作负载的类型
        public let kind: String

        /// 工作负载的名称
        public let name: String

        /// 容器名
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let container: String?

        /// 命名空间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let namespace: String?

        public init(kind: String, name: String, container: String? = nil, namespace: String? = nil) {
            self.kind = kind
            self.name = name
            self.container = container
            self.namespace = namespace
        }

        enum CodingKeys: String, CodingKey {
            case kind = "Kind"
            case name = "Name"
            case container = "Container"
            case namespace = "Namespace"
        }
    }

    /// 投递日志的内容格式配置
    public struct ContentInfo: TCInputModel, TCOutputModel {
        /// 内容格式，支持json、csv
        public let format: String

        /// csv格式内容描述
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let csv: CsvInfo?

        /// json格式内容描述
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let json: JsonInfo?

        /// parquet格式内容描述
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let parquet: ParquetInfo?

        public init(format: String, csv: CsvInfo? = nil, json: JsonInfo? = nil, parquet: ParquetInfo? = nil) {
            self.format = format
            self.csv = csv
            self.json = json
            self.parquet = parquet
        }

        enum CodingKeys: String, CodingKey {
            case format = "Format"
            case csv = "Csv"
            case json = "Json"
            case parquet = "Parquet"
        }
    }

    /// csv内容描述
    public struct CsvInfo: TCInputModel, TCOutputModel {
        /// csv首行是否打印key
        public let printKey: Bool

        /// 每列key的名字
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let keys: [String]?

        /// 各字段间的分隔符
        public let delimiter: String

        /// 若字段内容中包含分隔符，则使用该转义符包裹改字段，只能填写单引号、双引号、空字符串
        public let escapeChar: String

        /// 对于上面指定的不存在字段使用该内容填充
        public let nonExistingField: String

        public init(printKey: Bool, keys: [String], delimiter: String, escapeChar: String, nonExistingField: String) {
            self.printKey = printKey
            self.keys = keys
            self.delimiter = delimiter
            self.escapeChar = escapeChar
            self.nonExistingField = nonExistingField
        }

        enum CodingKeys: String, CodingKey {
            case printKey = "PrintKey"
            case keys = "Keys"
            case delimiter = "Delimiter"
            case escapeChar = "EscapeChar"
            case nonExistingField = "NonExistingField"
        }
    }

    /// 黑名单path信息
    public struct ExcludePathInfo: TCInputModel, TCOutputModel {
        /// 类型，选填File或Path
        public let type: String

        /// Type对应的具体内容
        public let value: String

        public init(type: String, value: String) {
            self.type = type
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    /// 日志导出信息
    public struct ExportInfo: TCOutputModel {
        /// 日志主题ID
        public let topicId: String

        /// 日志导出任务ID
        public let exportId: String

        /// 日志导出查询语句
        public let query: String

        /// 日志导出文件名
        public let fileName: String

        /// 日志文件大小
        public let fileSize: UInt64

        /// 日志导出时间排序
        public let order: String

        /// 日志导出格式
        public let format: String

        /// 日志导出数量
        public let count: UInt64

        /// 日志下载状态。Processing:导出正在进行中，Completed:导出完成，Failed:导出失败，Expired:日志导出已过期(三天有效期), Queuing 排队中
        public let status: String

        /// 日志导出起始时间
        public let from: Int64

        /// 日志导出结束时间
        public let to: Int64

        /// 日志导出路径
        public let cosPath: String

        /// 日志导出创建时间
        public let createTime: String

        enum CodingKeys: String, CodingKey {
            case topicId = "TopicId"
            case exportId = "ExportId"
            case query = "Query"
            case fileName = "FileName"
            case fileSize = "FileSize"
            case order = "Order"
            case format = "Format"
            case count = "Count"
            case status = "Status"
            case from = "From"
            case to = "To"
            case cosPath = "CosPath"
            case createTime = "CreateTime"
        }
    }

    /// 日志提取规则
    public struct ExtractRuleInfo: TCInputModel, TCOutputModel {
        /// 时间字段的key名字，time_key和time_format必须成对出现
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let timeKey: String?

        /// 时间字段的格式，参考c语言的strftime函数对于时间的格式说明输出参数
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let timeFormat: String?

        /// 分隔符类型日志的分隔符，只有log_type为delimiter_log时有效
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let delimiter: String?

        /// 整条日志匹配规则，只有log_type为fullregex_log时有效
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logRegex: String?

        /// 行首匹配规则，只有log_type为multiline_log或fullregex_log时有效
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let beginRegex: String?

        /// 取的每个字段的key名字，为空的key代表丢弃这个字段，只有log_type为delimiter_log时有效，json_log的日志使用json本身的key
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let keys: [String]?

        /// 需要过滤日志的key，及其对应的regex
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let filterKeyRegex: [KeyRegexInfo]?

        /// 解析失败日志是否上传，true表示上传，false表示不上传
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let unMatchUpLoadSwitch: Bool?

        /// 失败日志的key
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let unMatchLogKey: String?

        /// 增量采集模式下的回溯数据量，默认-1（全量采集）
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let backtracking: Int64?

        /// 是否为Gbk编码.   0: 否, 1: 是
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let isGBK: Int64?

        /// 是否为标准json.   0: 否, 1: 是
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let jsonStandard: Int64?

        /// syslog传输协议，取值为tcp或者udp。
        /// 该字段适用于：创建采集规则配置、修改采集规则配置
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let `protocol`: String?

        /// syslog系统日志采集指定采集器监听的地址和端口 ，形式：[ip]:[port]。举例：127.0.0.1:9000
        /// 该字段适用于：创建采集规则配置、修改采集规则配置
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let address: String?

        /// rfc3164：指定系统日志采集使用RFC3164协议解析日志。
        /// rfc5424：指定系统日志采集使用RFC5424协议解析日志。
        /// auto：自动匹配rfc3164或者rfc5424其中一种协议
        /// 该字段适用于：创建采集规则配置、修改采集规则配置
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let parseProtocol: String?

        public init(timeKey: String? = nil, timeFormat: String? = nil, delimiter: String? = nil, logRegex: String? = nil, beginRegex: String? = nil, keys: [String]? = nil, filterKeyRegex: [KeyRegexInfo]? = nil, unMatchUpLoadSwitch: Bool? = nil, unMatchLogKey: String? = nil, backtracking: Int64? = nil, isGBK: Int64? = nil, jsonStandard: Int64? = nil, protocol: String? = nil, address: String? = nil, parseProtocol: String? = nil) {
            self.timeKey = timeKey
            self.timeFormat = timeFormat
            self.delimiter = delimiter
            self.logRegex = logRegex
            self.beginRegex = beginRegex
            self.keys = keys
            self.filterKeyRegex = filterKeyRegex
            self.unMatchUpLoadSwitch = unMatchUpLoadSwitch
            self.unMatchLogKey = unMatchLogKey
            self.backtracking = backtracking
            self.isGBK = isGBK
            self.jsonStandard = jsonStandard
            self.protocol = `protocol`
            self.address = address
            self.parseProtocol = parseProtocol
        }

        enum CodingKeys: String, CodingKey {
            case timeKey = "TimeKey"
            case timeFormat = "TimeFormat"
            case delimiter = "Delimiter"
            case logRegex = "LogRegex"
            case beginRegex = "BeginRegex"
            case keys = "Keys"
            case filterKeyRegex = "FilterKeyRegex"
            case unMatchUpLoadSwitch = "UnMatchUpLoadSwitch"
            case unMatchLogKey = "UnMatchLogKey"
            case backtracking = "Backtracking"
            case isGBK = "IsGBK"
            case jsonStandard = "JsonStandard"
            case `protocol` = "Protocol"
            case address = "Address"
            case parseProtocol = "ParseProtocol"
        }
    }

    /// 过滤器
    public struct Filter: TCInputModel {
        /// 需要过滤的字段。
        public let key: String

        /// 需要过滤的值。
        public let values: [String]

        public init(key: String, values: [String]) {
            self.key = key
            self.values = values
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    /// 投递日志的过滤规则
    public struct FilterRuleInfo: TCInputModel, TCOutputModel {
        /// 过滤规则Key
        public let key: String

        /// 过滤规则
        public let regex: String

        /// 过滤规则Value
        public let value: String

        public init(key: String, regex: String, value: String) {
            self.key = key
            self.regex = regex
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case regex = "Regex"
            case value = "Value"
        }
    }

    /// 全文索引配置
    public struct FullTextInfo: TCInputModel, TCOutputModel {
        /// 是否大小写敏感
        public let caseSensitive: Bool

        /// 全文索引的分词符，其中的每个字符代表一个分词符；
        /// 仅支持英文符号、\n\t\r及转义符\；
        /// 注意：\n\t\r本身已被转义，直接使用双引号包裹即可作为入参，无需再次转义
        public let tokenizer: String

        /// 是否包含中文
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let containZH: Bool?

        public init(caseSensitive: Bool, tokenizer: String, containZH: Bool? = nil) {
            self.caseSensitive = caseSensitive
            self.tokenizer = tokenizer
            self.containZH = containZH
        }

        enum CodingKeys: String, CodingKey {
            case caseSensitive = "CaseSensitive"
            case tokenizer = "Tokenizer"
            case containZH = "ContainZH"
        }
    }

    /// 直方图详细信息
    public struct HistogramInfo: TCOutputModel {
        /// 统计周期内的日志条数
        public let count: Int64

        /// 按 period 取整后的 unix timestamp： 单位毫秒
        public let bTime: Int64

        enum CodingKeys: String, CodingKey {
            case count = "Count"
            case bTime = "BTime"
        }
    }

    /// 自建k8s-节点文件配置信息
    public struct HostFileInfo: TCInputModel, TCOutputModel {
        /// 日志文件夹
        public let logPath: String

        /// 日志文件名
        public let filePattern: String

        /// metadata信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let customLabels: [String]?

        public init(logPath: String, filePattern: String, customLabels: [String]? = nil) {
            self.logPath = logPath
            self.filePattern = filePattern
            self.customLabels = customLabels
        }

        enum CodingKeys: String, CodingKey {
            case logPath = "LogPath"
            case filePattern = "FilePattern"
            case customLabels = "CustomLabels"
        }
    }

    /// JSON类型描述
    public struct JsonInfo: TCInputModel, TCOutputModel {
        /// 启用标志
        public let enableTag: Bool

        /// 元数据信息列表, 可选值为 __SOURCE__、__FILENAME__、__TIMESTAMP__、__HOSTNAME__。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let metaFields: [String]?

        public init(enableTag: Bool, metaFields: [String]) {
            self.enableTag = enableTag
            self.metaFields = metaFields
        }

        enum CodingKeys: String, CodingKey {
            case enableTag = "EnableTag"
            case metaFields = "MetaFields"
        }
    }

    /// 需要过滤日志的key，及其对应的regex
    public struct KeyRegexInfo: TCInputModel, TCOutputModel {
        /// 需要过滤日志的key
        public let key: String

        /// key对应的过滤规则regex
        public let regex: String

        public init(key: String, regex: String) {
            self.key = key
            self.regex = regex
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case regex = "Regex"
        }
    }

    /// 键值或者元字段索引的字段信息
    public struct KeyValueInfo: TCInputModel, TCOutputModel {
        /// 需要配置键值或者元字段索引的字段名称，仅支持字母、数字、下划线和-./@，且不能以下划线开头
        ///
        /// 注意：
        /// 1，元字段（tag）的Key无需额外添加`__TAG__.`前缀，与上传日志时对应的字段Key一致即可，腾讯云控制台展示时将自动添加`__TAG__.`前缀
        /// 2，键值索引（KeyValue）及元字段索引（Tag）中的Key总数不能超过300
        /// 3，Key的层级不能超过10层，例如a.b.c.d.e.f.g.h.j.k
        /// 4，不允许同时包含json父子级字段，例如a及a.b
        public let key: String

        /// 字段的索引描述信息
        public let value: ValueInfo

        public init(key: String, value: ValueInfo) {
            self.key = key
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// 日志上下文信息
    public struct LogContextInfo: TCOutputModel {
        /// 日志来源设备
        public let source: String

        /// 采集路径
        public let filename: String

        /// 日志内容
        public let content: String

        /// 日志包序号
        public let pkgId: String

        /// 日志包内一条日志的序号
        public let pkgLogId: Int64

        /// 日志时间戳
        public let bTime: Int64

        /// 日志来源主机名称
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let hostName: String?

        enum CodingKeys: String, CodingKey {
            case source = "Source"
            case filename = "Filename"
            case content = "Content"
            case pkgId = "PkgId"
            case pkgLogId = "PkgLogId"
            case bTime = "BTime"
            case hostName = "HostName"
        }
    }

    /// 日志结果信息
    public struct LogInfo: TCOutputModel {
        /// 日志时间，单位ms
        public let time: Int64

        /// 日志主题ID
        public let topicId: String

        /// 日志主题名称
        public let topicName: String

        /// 日志来源IP
        public let source: String

        /// 日志文件名称
        public let fileName: String

        /// 日志上报请求包的ID
        public let pkgId: String

        /// 请求包内日志的ID
        public let pkgLogId: String

        /// 日志内容的Json序列化字符串
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let logJson: String?

        /// 日志来源主机名称
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let hostName: String?

        enum CodingKeys: String, CodingKey {
            case time = "Time"
            case topicId = "TopicId"
            case topicName = "TopicName"
            case source = "Source"
            case fileName = "FileName"
            case pkgId = "PkgId"
            case pkgLogId = "PkgLogId"
            case logJson = "LogJson"
            case hostName = "HostName"
        }
    }

    /// 日志中的KV对
    public struct LogItem: TCOutputModel {
        /// 日志Key
        public let key: String

        /// 日志Value
        public let value: String

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// LogItem的数组
    public struct LogItems: TCOutputModel {
        /// 分析结果返回的KV数据对
        public let data: [LogItem]

        enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    /// 日志集相关信息
    public struct LogsetInfo: TCOutputModel {
        /// 日志集ID
        public let logsetId: String

        /// 日志集名称
        public let logsetName: String

        /// 创建时间
        public let createTime: String

        /// 云产品标识，日志集由其它云产品创建时，该字段会显示云产品名称，例如CDN、TKE
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let assumerName: String?

        /// 日志集绑定的标签
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let tags: [Tag]?

        /// 日志集下日志主题的数目
        public let topicCount: Int64

        /// 若AssumerName非空，则表示创建该日志集的服务方角色
        public let roleName: String

        enum CodingKeys: String, CodingKey {
            case logsetId = "LogsetId"
            case logsetName = "LogsetName"
            case createTime = "CreateTime"
            case assumerName = "AssumerName"
            case tags = "Tags"
            case topicCount = "TopicCount"
            case roleName = "RoleName"
        }
    }

    /// 机器组信息
    public struct MachineGroupInfo: TCOutputModel {
        /// 机器组ID
        public let groupId: String

        /// 机器组名称
        public let groupName: String

        /// 机器组类型
        public let machineGroupType: MachineGroupTypeInfo

        /// 创建时间
        public let createTime: String

        /// 机器组绑定的标签列表
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let tags: [Tag]?

        /// 是否开启机器组自动更新
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let autoUpdate: String?

        /// 升级开始时间，建议业务低峰期升级LogListener
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let updateStartTime: String?

        /// 升级结束时间，建议业务低峰期升级LogListener
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let updateEndTime: String?

        /// 是否开启服务日志，用于记录因Loglistener 服务自身产生的log，开启后，会创建内部日志集cls_service_logging和日志主题loglistener_status,loglistener_alarm,loglistener_business，不产生计费
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let serviceLogging: Bool?

        enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case machineGroupType = "MachineGroupType"
            case createTime = "CreateTime"
            case tags = "Tags"
            case autoUpdate = "AutoUpdate"
            case updateStartTime = "UpdateStartTime"
            case updateEndTime = "UpdateEndTime"
            case serviceLogging = "ServiceLogging"
        }
    }

    /// 机器组类型描述
    public struct MachineGroupTypeInfo: TCInputModel, TCOutputModel {
        /// 机器组类型，ip表示该机器组Values中存的是采集机器的IP地址，label表示该机器组Values中存储的是机器的标签
        public let type: String

        /// 机器描述列表
        public let values: [String]

        public init(type: String, values: [String]) {
            self.type = type
            self.values = values
        }

        enum CodingKeys: String, CodingKey {
            case type = "Type"
            case values = "Values"
        }
    }

    /// 机器状态信息
    public struct MachineInfo: TCOutputModel {
        /// 机器的IP
        public let ip: String

        /// 机器状态，0:异常，1:正常
        public let status: UInt64

        /// 机器离线时间，空为正常，异常返回具体时间
        public let offlineTime: String

        /// 机器是否开启自动升级。0:关闭，1:开启
        public let autoUpdate: Int64

        /// 机器当前版本号。
        public let version: String

        /// 机器升级功能状态。
        public let updateStatus: Int64

        /// 机器升级结果标识。
        public let errCode: Int64

        /// 机器升级结果信息。
        public let errMsg: String

        enum CodingKeys: String, CodingKey {
            case ip = "Ip"
            case status = "Status"
            case offlineTime = "OfflineTime"
            case autoUpdate = "AutoUpdate"
            case version = "Version"
            case updateStatus = "UpdateStatus"
            case errCode = "ErrCode"
            case errMsg = "ErrMsg"
        }
    }

    /// 告警策略中监控任务的执行时间点
    public struct MonitorTime: TCInputModel, TCOutputModel {
        /// 可选值：
        /// <br><li> Period - 周期执行
        /// <br><li> Fixed - 定期执行
        public let type: String

        /// 执行的周期，或者定制执行的时间节点。单位为分钟，取值范围为1~1440。
        public let time: Int64

        public init(type: String, time: Int64) {
            self.type = type
            self.time = time
        }

        enum CodingKeys: String, CodingKey {
            case type = "Type"
            case time = "Time"
        }
    }

    /// 告警通知接收者信息
    public struct NoticeReceiver: TCInputModel, TCOutputModel {
        /// 接受者类型。可选值：
        /// <br><li> Uin - 用户ID
        /// <br><li> Group - 用户组ID
        /// 暂不支持其余接收者类型。
        public let receiverType: String

        /// 接收者。
        public let receiverIds: [Int64]

        /// 通知接收渠道。
        /// <br><li> Email - 邮件
        /// <br><li> Sms - 短信
        /// <br><li> WeChat - 微信
        /// <br><li> Phone - 电话
        public let receiverChannels: [String]

        /// 允许接收信息的开始时间。
        public let startTime: String?

        /// 允许接收信息的结束时间。
        public let endTime: String?

        /// 位序
        public let index: Int64?

        public init(receiverType: String, receiverIds: [Int64], receiverChannels: [String], startTime: String? = nil, endTime: String? = nil, index: Int64? = nil) {
            self.receiverType = receiverType
            self.receiverIds = receiverIds
            self.receiverChannels = receiverChannels
            self.startTime = startTime
            self.endTime = endTime
            self.index = index
        }

        enum CodingKeys: String, CodingKey {
            case receiverType = "ReceiverType"
            case receiverIds = "ReceiverIds"
            case receiverChannels = "ReceiverChannels"
            case startTime = "StartTime"
            case endTime = "EndTime"
            case index = "Index"
        }
    }

    /// Parquet内容
    public struct ParquetInfo: TCInputModel, TCOutputModel {
        /// ParquetKeyInfo数组
        public let parquetKeyInfo: [ParquetKeyInfo]

        public init(parquetKeyInfo: [ParquetKeyInfo]) {
            self.parquetKeyInfo = parquetKeyInfo
        }

        enum CodingKeys: String, CodingKey {
            case parquetKeyInfo = "ParquetKeyInfo"
        }
    }

    /// Parquet内容描述
    public struct ParquetKeyInfo: TCInputModel, TCOutputModel {
        /// 键值名称
        public let keyName: String

        /// 数据类型，目前支持6种类型：string、boolean、int32、int64、float、double
        public let keyType: String

        /// 解析失败赋值信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let keyNonExistingField: String?

        public init(keyName: String, keyType: String, keyNonExistingField: String) {
            self.keyName = keyName
            self.keyType = keyType
            self.keyNonExistingField = keyNonExistingField
        }

        enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case keyType = "KeyType"
            case keyNonExistingField = "KeyNonExistingField"
        }
    }

    /// 日志主题分区信息
    public struct PartitionInfo: TCOutputModel {
        /// 分区ID
        public let partitionId: Int64

        /// 分区的状态（readwrite或者是readonly）
        public let status: String

        /// 分区哈希键起始key
        public let inclusiveBeginKey: String

        /// 分区哈希键结束key
        public let exclusiveEndKey: String

        /// 分区创建时间
        public let createTime: String

        /// 只读分区数据停止写入时间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let lastWriteTime: String?

        enum CodingKeys: String, CodingKey {
            case partitionId = "PartitionId"
            case status = "Status"
            case inclusiveBeginKey = "InclusiveBeginKey"
            case exclusiveEndKey = "ExclusiveEndKey"
            case createTime = "CreateTime"
            case lastWriteTime = "LastWriteTime"
        }
    }

    /// 索引规则，FullText、KeyValue、Tag参数必须输入一个有效参数
    public struct RuleInfo: TCInputModel, TCOutputModel {
        /// 全文索引配置, 如果为空时代表未开启全文索引
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let fullText: FullTextInfo?

        /// 键值索引配置，如果为空时代表未开启键值索引
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let keyValue: RuleKeyValueInfo?

        /// 元字段索引配置，如果为空时代表未开启元字段索引
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let tag: RuleTagInfo?

        public init(fullText: FullTextInfo? = nil, keyValue: RuleKeyValueInfo? = nil, tag: RuleTagInfo? = nil) {
            self.fullText = fullText
            self.keyValue = keyValue
            self.tag = tag
        }

        enum CodingKeys: String, CodingKey {
            case fullText = "FullText"
            case keyValue = "KeyValue"
            case tag = "Tag"
        }
    }

    /// 键值索引配置
    public struct RuleKeyValueInfo: TCInputModel, TCOutputModel {
        /// 是否大小写敏感
        public let caseSensitive: Bool

        /// 需要建立索引的键值对信息
        public let keyValues: [KeyValueInfo]?

        public init(caseSensitive: Bool, keyValues: [KeyValueInfo]? = nil) {
            self.caseSensitive = caseSensitive
            self.keyValues = keyValues
        }

        enum CodingKeys: String, CodingKey {
            case caseSensitive = "CaseSensitive"
            case keyValues = "KeyValues"
        }
    }

    /// 元字段索引配置
    public struct RuleTagInfo: TCInputModel, TCOutputModel {
        /// 是否大小写敏感
        public let caseSensitive: Bool

        /// 元字段索引配置中的字段信息
        public let keyValues: [KeyValueInfo]

        public init(caseSensitive: Bool, keyValues: [KeyValueInfo]) {
            self.caseSensitive = caseSensitive
            self.keyValues = keyValues
        }

        enum CodingKeys: String, CodingKey {
            case caseSensitive = "CaseSensitive"
            case keyValues = "KeyValues"
        }
    }

    /// 投递规则
    public struct ShipperInfo: TCOutputModel {
        /// 投递规则ID
        public let shipperId: String

        /// 日志主题ID
        public let topicId: String

        /// 投递的bucket地址
        public let bucket: String

        /// 投递的前缀目录
        public let prefix: String

        /// 投递规则的名字
        public let shipperName: String

        /// 投递的时间间隔，单位 秒
        public let interval: UInt64

        /// 投递的文件的最大值，单位 MB
        public let maxSize: UInt64

        /// 是否生效
        public let status: Bool

        /// 投递日志的过滤规则
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let filterRules: [FilterRuleInfo]?

        /// 投递日志的分区规则，支持strftime的时间格式表示
        public let partition: String

        /// 投递日志的压缩配置
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let compress: CompressInfo?

        /// 投递日志的内容格式配置
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let content: ContentInfo?

        /// 投递日志的创建时间
        public let createTime: String

        /// 投递文件命名配置，0：随机数命名，1：投递时间命名，默认0（随机数命名）
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let filenameMode: UInt64?

        enum CodingKeys: String, CodingKey {
            case shipperId = "ShipperId"
            case topicId = "TopicId"
            case bucket = "Bucket"
            case prefix = "Prefix"
            case shipperName = "ShipperName"
            case interval = "Interval"
            case maxSize = "MaxSize"
            case status = "Status"
            case filterRules = "FilterRules"
            case partition = "Partition"
            case compress = "Compress"
            case content = "Content"
            case createTime = "CreateTime"
            case filenameMode = "FilenameMode"
        }
    }

    /// 投递任务信息
    public struct ShipperTaskInfo: TCOutputModel {
        /// 投递任务ID
        public let taskId: String

        /// 投递信息ID
        public let shipperId: String

        /// 日志主题ID
        public let topicId: String

        /// 本批投递的日志的开始时间戳，毫秒
        public let rangeStart: Int64

        /// 本批投递的日志的结束时间戳， 毫秒
        public let rangeEnd: Int64

        /// 本次投递任务的开始时间戳， 毫秒
        public let startTime: Int64

        /// 本次投递任务的结束时间戳， 毫秒
        public let endTime: Int64

        /// 本次投递的结果，"success","running","failed"
        public let status: String

        /// 结果的详细信息
        public let message: String

        enum CodingKeys: String, CodingKey {
            case taskId = "TaskId"
            case shipperId = "ShipperId"
            case topicId = "TopicId"
            case rangeStart = "RangeStart"
            case rangeEnd = "RangeEnd"
            case startTime = "StartTime"
            case endTime = "EndTime"
            case status = "Status"
            case message = "Message"
        }
    }

    /// 创建资源实例时同时绑定的标签对说明
    public struct Tag: TCInputModel {
        /// 标签键
        public let key: String

        /// 标签值
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// 日志主题信息
    public struct TopicInfo: TCOutputModel {
        /// 日志集ID
        public let logsetId: String

        /// 日志主题ID
        public let topicId: String

        /// 日志主题名称
        public let topicName: String

        /// 主题分区个数
        public let partitionCount: Int64

        /// 是否开启索引
        public let index: Bool

        /// 云产品标识，日志主题由其它云产品创建时，该字段会显示云产品名称，例如CDN、TKE
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let assumerName: String?

        /// 创建时间
        public let createTime: String

        /// 日主主题是否开启采集
        public let status: Bool

        /// 日志主题绑定的标签信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let tags: [Tag]?

        /// 该主题是否开启自动分裂
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let autoSplit: Bool?

        /// 若开启自动分裂的话，该主题能够允许的最大分区数
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let maxSplitPartitions: Int64?

        /// 日主题的存储类型
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let storageType: String?

        /// 生命周期，单位天，可取值范围1~3600。取值为3640时代表永久保存
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let period: Int64?

        /// 云产品二级标识，日志主题由其它云产品创建时，该字段会显示云产品名称及其日志类型的二级分类，例如TKE-Audit、TKE-Event。部分云产品仅有云产品标识(AssumerName)，无该字段。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let subAssumerName: String?

        /// 日志主题描述
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let describes: String?

        enum CodingKeys: String, CodingKey {
            case logsetId = "LogsetId"
            case topicId = "TopicId"
            case topicName = "TopicName"
            case partitionCount = "PartitionCount"
            case index = "Index"
            case assumerName = "AssumerName"
            case createTime = "CreateTime"
            case status = "Status"
            case tags = "Tags"
            case autoSplit = "AutoSplit"
            case maxSplitPartitions = "MaxSplitPartitions"
            case storageType = "StorageType"
            case period = "Period"
            case subAssumerName = "SubAssumerName"
            case describes = "Describes"
        }
    }

    /// 需要开启键值索引的字段的索引描述信息
    public struct ValueInfo: TCInputModel, TCOutputModel {
        /// 字段类型，目前支持的类型有：long、text、double
        public let type: String

        /// 字段的分词符，其中的每个字符代表一个分词符；
        /// 仅支持英文符号、\n\t\r及转义符\；
        /// long及double类型字段需为空；
        /// 注意：\n\t\r本身已被转义，直接使用双引号包裹即可作为入参，无需再次转义
        public let tokenizer: String?

        /// 字段是否开启分析功能
        public let sqlFlag: Bool?

        /// 是否包含中文，long及double类型字段需为false
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let containZH: Bool?

        public init(type: String, tokenizer: String? = nil, sqlFlag: Bool? = nil, containZH: Bool? = nil) {
            self.type = type
            self.tokenizer = tokenizer
            self.sqlFlag = sqlFlag
            self.containZH = containZH
        }

        enum CodingKeys: String, CodingKey {
            case type = "Type"
            case tokenizer = "Tokenizer"
            case sqlFlag = "SqlFlag"
            case containZH = "ContainZH"
        }
    }

    /// 回调地址
    public struct WebCallback: TCInputModel, TCOutputModel {
        /// 回调地址。
        public let url: String

        /// 回调的类型。可选值：
        /// <li> WeCom
        /// <li> Http
        public let callbackType: String

        /// 回调方法。可选值：
        /// <li> POST
        /// <li> PUT
        /// 默认值为POST。CallbackType为Http时为必选。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let method: String?

        /// 请求头。
        /// 注意：该参数已废弃，请在<a href="https://cloud.tencent.com/document/product/614/56466">创建告警策略</a>接口CallBack参数中指定请求头。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let headers: [String]?

        /// 请求内容。
        /// 注意：该参数已废弃，请在<a href="https://cloud.tencent.com/document/product/614/56466">创建告警策略</a>接口CallBack参数中指定请求内容。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let body: String?

        /// 序号
        public let index: Int64?

        public init(url: String, callbackType: String, method: String? = nil, headers: [String]? = nil, body: String? = nil, index: Int64? = nil) {
            self.url = url
            self.callbackType = callbackType
            self.method = method
            self.headers = headers
            self.body = body
            self.index = index
        }

        enum CodingKeys: String, CodingKey {
            case url = "Url"
            case callbackType = "CallbackType"
            case method = "Method"
            case headers = "Headers"
            case body = "Body"
            case index = "Index"
        }
    }
}
