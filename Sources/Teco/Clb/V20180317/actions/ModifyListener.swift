//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

import Logging
import NIOCore
import TecoCore

extension Clb {
    /// ModifyListener请求参数结构体
    public struct ModifyListenerRequest: TCRequest {
        /// 负载均衡实例ID。
        public let loadBalancerId: String

        /// 负载均衡监听器ID。
        public let listenerId: String

        /// 新的监听器名称。
        public let listenerName: String?

        /// 会话保持时间，单位：秒。可选值：30~3600，默认 0，表示不开启。此参数仅适用于TCP/UDP监听器。
        public let sessionExpireTime: Int64?

        /// 健康检查相关参数，此参数仅适用于TCP/UDP/TCP_SSL/QUIC监听器。
        public let healthCheck: HealthCheck?

        /// 证书相关信息，此参数仅适用于HTTPS/TCP_SSL/QUIC监听器；此参数和MultiCertInfo不能同时传入。
        public let certificate: CertificateInput?

        /// 监听器转发的方式。可选值：WRR、LEAST_CONN
        /// 分别表示按权重轮询、最小连接数， 默认为 WRR。
        public let scheduler: String?

        /// 是否开启SNI特性，此参数仅适用于HTTPS监听器。注意：未开启SNI的监听器可以开启SNI；已开启SNI的监听器不能关闭SNI。
        public let sniSwitch: Int64?

        /// 后端目标类型，NODE表示绑定普通节点，TARGETGROUP表示绑定目标组。
        public let targetType: String?

        /// 是否开启长连接，此参数仅适用于HTTP/HTTPS监听器。
        public let keepaliveEnable: Int64?

        /// 解绑后端目标时，是否发RST给客户端，此参数仅适用于TCP监听器。
        public let deregisterTargetRst: Bool?

        /// 会话保持类型。NORMAL表示默认会话保持类型。QUIC_CID表示根据Quic Connection ID做会话保持。QUIC_CID只支持UDP协议。
        public let sessionType: String?

        /// 证书信息，支持同时传入不同算法类型的多本服务端证书；此参数仅适用于未开启SNI特性的HTTPS监听器。此参数和Certificate不能同时传入。
        public let multiCertInfo: MultiCertInfo?

        /// 监听器粒度并发连接数上限，当前仅性能容量型实例且仅TCP/UDP/TCP_SSL/QUIC监听器支持。取值范围：1-实例规格并发连接上限，其中-1表示关闭监听器粒度并发连接数限速。
        public let maxConn: Int64?

        /// 监听器粒度新建连接数上限，当前仅性能容量型实例且仅TCP/UDP/TCP_SSL/QUIC监听器支持。取值范围：1-实例规格新建连接上限，其中-1表示关闭监听器粒度新建连接数限速。
        public let maxCps: Int64?

        /// 空闲连接超时时间，此参数仅适用于TCP监听器，单位：秒。默认值：900，取值范围：共享型实例和独占型实例支持：300～900，性能容量型实例支持：300~2000。如需设置超过2000s，请通过 [工单申请](https://console.cloud.tencent.com/workorder/category),最大可设置到3600s。
        public let idleConnectTimeout: Int64?

        public init(loadBalancerId: String, listenerId: String, listenerName: String? = nil, sessionExpireTime: Int64? = nil, healthCheck: HealthCheck? = nil, certificate: CertificateInput? = nil, scheduler: String? = nil, sniSwitch: Int64? = nil, targetType: String? = nil, keepaliveEnable: Int64? = nil, deregisterTargetRst: Bool? = nil, sessionType: String? = nil, multiCertInfo: MultiCertInfo? = nil, maxConn: Int64? = nil, maxCps: Int64? = nil, idleConnectTimeout: Int64? = nil) {
            self.loadBalancerId = loadBalancerId
            self.listenerId = listenerId
            self.listenerName = listenerName
            self.sessionExpireTime = sessionExpireTime
            self.healthCheck = healthCheck
            self.certificate = certificate
            self.scheduler = scheduler
            self.sniSwitch = sniSwitch
            self.targetType = targetType
            self.keepaliveEnable = keepaliveEnable
            self.deregisterTargetRst = deregisterTargetRst
            self.sessionType = sessionType
            self.multiCertInfo = multiCertInfo
            self.maxConn = maxConn
            self.maxCps = maxCps
            self.idleConnectTimeout = idleConnectTimeout
        }

        enum CodingKeys: String, CodingKey {
            case loadBalancerId = "LoadBalancerId"
            case listenerId = "ListenerId"
            case listenerName = "ListenerName"
            case sessionExpireTime = "SessionExpireTime"
            case healthCheck = "HealthCheck"
            case certificate = "Certificate"
            case scheduler = "Scheduler"
            case sniSwitch = "SniSwitch"
            case targetType = "TargetType"
            case keepaliveEnable = "KeepaliveEnable"
            case deregisterTargetRst = "DeregisterTargetRst"
            case sessionType = "SessionType"
            case multiCertInfo = "MultiCertInfo"
            case maxConn = "MaxConn"
            case maxCps = "MaxCps"
            case idleConnectTimeout = "IdleConnectTimeout"
        }
    }

    /// ModifyListener返回参数结构体
    public struct ModifyListenerResponse: TCResponse {
        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    /// 修改负载均衡监听器属性
    ///
    /// ModifyListener接口用来修改负载均衡监听器的属性，包括监听器名称、健康检查参数、证书信息、转发策略等。本接口不支持传统型负载均衡。
    /// 本接口为异步接口，本接口返回成功后需以返回的RequestID为入参，调用DescribeTaskStatus接口查询本次任务是否成功。
    @inlinable @discardableResult
    public func modifyListener(_ input: ModifyListenerRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ModifyListenerResponse> {
        self.client.execute(action: "ModifyListener", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 修改负载均衡监听器属性
    ///
    /// ModifyListener接口用来修改负载均衡监听器的属性，包括监听器名称、健康检查参数、证书信息、转发策略等。本接口不支持传统型负载均衡。
    /// 本接口为异步接口，本接口返回成功后需以返回的RequestID为入参，调用DescribeTaskStatus接口查询本次任务是否成功。
    @inlinable @discardableResult
    public func modifyListener(_ input: ModifyListenerRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ModifyListenerResponse {
        try await self.client.execute(action: "ModifyListener", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 修改负载均衡监听器属性
    ///
    /// ModifyListener接口用来修改负载均衡监听器的属性，包括监听器名称、健康检查参数、证书信息、转发策略等。本接口不支持传统型负载均衡。
    /// 本接口为异步接口，本接口返回成功后需以返回的RequestID为入参，调用DescribeTaskStatus接口查询本次任务是否成功。
    @inlinable @discardableResult
    public func modifyListener(loadBalancerId: String, listenerId: String, listenerName: String? = nil, sessionExpireTime: Int64? = nil, healthCheck: HealthCheck? = nil, certificate: CertificateInput? = nil, scheduler: String? = nil, sniSwitch: Int64? = nil, targetType: String? = nil, keepaliveEnable: Int64? = nil, deregisterTargetRst: Bool? = nil, sessionType: String? = nil, multiCertInfo: MultiCertInfo? = nil, maxConn: Int64? = nil, maxCps: Int64? = nil, idleConnectTimeout: Int64? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ModifyListenerResponse> {
        self.modifyListener(.init(loadBalancerId: loadBalancerId, listenerId: listenerId, listenerName: listenerName, sessionExpireTime: sessionExpireTime, healthCheck: healthCheck, certificate: certificate, scheduler: scheduler, sniSwitch: sniSwitch, targetType: targetType, keepaliveEnable: keepaliveEnable, deregisterTargetRst: deregisterTargetRst, sessionType: sessionType, multiCertInfo: multiCertInfo, maxConn: maxConn, maxCps: maxCps, idleConnectTimeout: idleConnectTimeout), region: region, logger: logger, on: eventLoop)
    }

    /// 修改负载均衡监听器属性
    ///
    /// ModifyListener接口用来修改负载均衡监听器的属性，包括监听器名称、健康检查参数、证书信息、转发策略等。本接口不支持传统型负载均衡。
    /// 本接口为异步接口，本接口返回成功后需以返回的RequestID为入参，调用DescribeTaskStatus接口查询本次任务是否成功。
    @inlinable @discardableResult
    public func modifyListener(loadBalancerId: String, listenerId: String, listenerName: String? = nil, sessionExpireTime: Int64? = nil, healthCheck: HealthCheck? = nil, certificate: CertificateInput? = nil, scheduler: String? = nil, sniSwitch: Int64? = nil, targetType: String? = nil, keepaliveEnable: Int64? = nil, deregisterTargetRst: Bool? = nil, sessionType: String? = nil, multiCertInfo: MultiCertInfo? = nil, maxConn: Int64? = nil, maxCps: Int64? = nil, idleConnectTimeout: Int64? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ModifyListenerResponse {
        try await self.modifyListener(.init(loadBalancerId: loadBalancerId, listenerId: listenerId, listenerName: listenerName, sessionExpireTime: sessionExpireTime, healthCheck: healthCheck, certificate: certificate, scheduler: scheduler, sniSwitch: sniSwitch, targetType: targetType, keepaliveEnable: keepaliveEnable, deregisterTargetRst: deregisterTargetRst, sessionType: sessionType, multiCertInfo: multiCertInfo, maxConn: maxConn, maxCps: maxCps, idleConnectTimeout: idleConnectTimeout), region: region, logger: logger, on: eventLoop)
    }
}
