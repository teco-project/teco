//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project.
//
// Copyright (c) 2022 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

@_exported import struct Foundation.Date
import TecoDateHelpers

extension Scf {
    /// HTTP域名相关信息
    public struct AccessInfo: TCInputModel, TCOutputModel {
        /// 域名
        public let host: String

        /// VIP
        public let vip: String

        public init(host: String, vip: String) {
            self.host = host
            self.vip = vip
        }

        enum CodingKeys: String, CodingKey {
            case host = "Host"
            case vip = "Vip"
        }
    }

    /// 函数的版本别名
    public struct Alias: TCInputModel, TCOutputModel {
        /// 别名指向的主版本
        public let functionVersion: String

        /// 别名的名称
        public let name: String

        /// 别名的路由信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let routingConfig: RoutingConfig?

        /// 描述信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let description: String?

        /// 创建时间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var addTime: Date?

        /// 更新时间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var modTime: Date?

        public init(functionVersion: String, name: String, routingConfig: RoutingConfig, description: String? = nil, addTime: Date? = nil, modTime: Date? = nil) {
            self.functionVersion = functionVersion
            self.name = name
            self.routingConfig = routingConfig
            self.description = description
            self._addTime = .init(wrappedValue: addTime)
            self._modTime = .init(wrappedValue: modTime)
        }

        enum CodingKeys: String, CodingKey {
            case functionVersion = "FunctionVersion"
            case name = "Name"
            case routingConfig = "RoutingConfig"
            case description = "Description"
            case addTime = "AddTime"
            case modTime = "ModTime"
        }
    }

    /// 异步事件
    public struct AsyncEvent: TCOutputModel {
        /// 调用请求id
        public let invokeRequestId: String

        /// 调用类型
        public let invokeType: String

        /// 函数版本
        public let qualifier: String

        /// 事件状态，RUNNING 表示运行中, FINISHED 表示调用成功, ABORTED 表示调用终止, FAILED 表示调用失败
        public let status: String

        /// 调用开始时间，格式: "%Y-%m-%d %H:%M:%S.%f"
        public let startTime: String

        /// 调用结束时间，格式: "%Y-%m-%d %H:%M:%S.%f"
        public let endTime: String

        enum CodingKeys: String, CodingKey {
            case invokeRequestId = "InvokeRequestId"
            case invokeType = "InvokeType"
            case qualifier = "Qualifier"
            case status = "Status"
            case startTime = "StartTime"
            case endTime = "EndTime"
        }
    }

    /// 异步事件状态
    public struct AsyncEventStatus: TCOutputModel {
        /// 异步事件状态，RUNNING 表示运行中, FINISHED 表示调用成功, ABORTED 表示调用终止, FAILED 表示调用失败。
        public let status: String

        /// 请求状态码
        public let statusCode: Int64

        /// 异步执行请求 Id
        public let invokeRequestId: String

        enum CodingKeys: String, CodingKey {
            case status = "Status"
            case statusCode = "StatusCode"
            case invokeRequestId = "InvokeRequestId"
        }
    }

    /// 函数的异步重试配置详情
    public struct AsyncTriggerConfig: TCInputModel, TCOutputModel {
        /// 用户错误的异步重试重试配置
        public let retryConfig: [RetryConfig]

        /// 消息保留时间
        public let msgTTL: Int64

        public init(retryConfig: [RetryConfig], msgTTL: Int64) {
            self.retryConfig = retryConfig
            self.msgTTL = msgTTL
        }

        enum CodingKeys: String, CodingKey {
            case retryConfig = "RetryConfig"
            case msgTTL = "MsgTTL"
        }
    }

    /// 文件系统(cfs)配置描述
    public struct CfsConfig: TCInputModel, TCOutputModel {
        /// 文件系统信息列表
        public let cfsInsList: [CfsInsInfo]

        public init(cfsInsList: [CfsInsInfo]) {
            self.cfsInsList = cfsInsList
        }

        enum CodingKeys: String, CodingKey {
            case cfsInsList = "CfsInsList"
        }
    }

    /// 云函数关联的cfs配置信息
    public struct CfsInsInfo: TCInputModel, TCOutputModel {
        /// 用户id
        public let userId: String

        /// 用户组id
        public let userGroupId: String

        /// 文件系统实例id
        public let cfsId: String

        /// 文件系统挂载点id
        public let mountInsId: String

        /// 本地挂载点
        public let localMountDir: String

        /// 远程挂载点
        public let remoteMountDir: String

        /// 文件系统ip，配置 cfs 时无需填写。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let ipAddress: String?

        /// 文件系统所在的私有网络id，配置 cfs 时无需填写。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let mountVpcId: String?

        /// 文件系统所在私有网络的子网id，配置 cfs 时无需填写。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let mountSubnetId: String?

        public init(userId: String, userGroupId: String, cfsId: String, mountInsId: String, localMountDir: String, remoteMountDir: String, ipAddress: String? = nil, mountVpcId: String? = nil, mountSubnetId: String? = nil) {
            self.userId = userId
            self.userGroupId = userGroupId
            self.cfsId = cfsId
            self.mountInsId = mountInsId
            self.localMountDir = localMountDir
            self.remoteMountDir = remoteMountDir
            self.ipAddress = ipAddress
            self.mountVpcId = mountVpcId
            self.mountSubnetId = mountSubnetId
        }

        enum CodingKeys: String, CodingKey {
            case userId = "UserId"
            case userGroupId = "UserGroupId"
            case cfsId = "CfsId"
            case mountInsId = "MountInsId"
            case localMountDir = "LocalMountDir"
            case remoteMountDir = "RemoteMountDir"
            case ipAddress = "IpAddress"
            case mountVpcId = "MountVpcId"
            case mountSubnetId = "MountSubnetId"
        }
    }

    /// 函数代码
    public struct Code: TCInputModel {
        /// 对象存储桶名称（填写存储桶名称自定义部分，不包含-appid）
        public let cosBucketName: String?

        /// 对象存储中代码包文件路径，以/开头
        public let cosObjectName: String?

        /// 包含函数代码文件及其依赖项的 zip 格式文件，zip包大小上限为 50MB，使用该接口时要求将 zip 文件的内容转成 base64 编码
        public let zipFile: String?

        /// 对象存储的地域，地域为北京时需要传入ap-beijing,北京一区时需要传递ap-beijing-1，其他的地域不需要传递。
        public let cosBucketRegion: String?

        /// 如果是通过Demo创建的话，需要传入DemoId
        public let demoId: String?

        /// 如果是从TempCos创建的话，需要传入TempCosObjectName
        public let tempCosObjectName: String?

        /// Git地址。该功能已下线。
        public let gitUrl: String?

        /// Git用户名。该功能已下线。
        public let gitUserName: String?

        /// Git密码。该功能已下线。
        public let gitPassword: String?

        /// 加密后的Git密码，一般无需指定。该功能已下线。
        public let gitPasswordSecret: String?

        /// Git分支。该功能已下线。
        public let gitBranch: String?

        /// 代码在Git仓库中的路径。该功能已下线。
        public let gitDirectory: String?

        /// 指定要拉取的版本。该功能已下线。
        public let gitCommitId: String?

        /// 加密后的Git用户名，一般无需指定。该功能已下线。
        public let gitUserNameSecret: String?

        /// 镜像部署时配置TCR镜像信息
        public let imageConfig: ImageConfig?

        public init(cosBucketName: String? = nil, cosObjectName: String? = nil, zipFile: String? = nil, cosBucketRegion: String? = nil, demoId: String? = nil, tempCosObjectName: String? = nil, gitUrl: String? = nil, gitUserName: String? = nil, gitPassword: String? = nil, gitPasswordSecret: String? = nil, gitBranch: String? = nil, gitDirectory: String? = nil, gitCommitId: String? = nil, gitUserNameSecret: String? = nil, imageConfig: ImageConfig? = nil) {
            self.cosBucketName = cosBucketName
            self.cosObjectName = cosObjectName
            self.zipFile = zipFile
            self.cosBucketRegion = cosBucketRegion
            self.demoId = demoId
            self.tempCosObjectName = tempCosObjectName
            self.gitUrl = gitUrl
            self.gitUserName = gitUserName
            self.gitPassword = gitPassword
            self.gitPasswordSecret = gitPasswordSecret
            self.gitBranch = gitBranch
            self.gitDirectory = gitDirectory
            self.gitCommitId = gitCommitId
            self.gitUserNameSecret = gitUserNameSecret
            self.imageConfig = imageConfig
        }

        enum CodingKeys: String, CodingKey {
            case cosBucketName = "CosBucketName"
            case cosObjectName = "CosObjectName"
            case zipFile = "ZipFile"
            case cosBucketRegion = "CosBucketRegion"
            case demoId = "DemoId"
            case tempCosObjectName = "TempCosObjectName"
            case gitUrl = "GitUrl"
            case gitUserName = "GitUserName"
            case gitPassword = "GitPassword"
            case gitPasswordSecret = "GitPasswordSecret"
            case gitBranch = "GitBranch"
            case gitDirectory = "GitDirectory"
            case gitCommitId = "GitCommitId"
            case gitUserNameSecret = "GitUserNameSecret"
            case imageConfig = "ImageConfig"
        }
    }

    /// 死信队列参数
    public struct DeadLetterConfig: TCInputModel {
        /// 死信队列模式
        public let type: String

        /// 死信队列名称
        public let name: String

        /// 死信队列主题模式的标签形式
        public let filterType: String?

        public init(type: String, name: String, filterType: String? = nil) {
            self.type = type
            self.name = name
            self.filterType = filterType
        }

        enum CodingKeys: String, CodingKey {
            case type = "Type"
            case name = "Name"
            case filterType = "FilterType"
        }
    }

    /// 公网访问固定ip配置
    public struct EipConfigIn: TCInputModel {
        /// Eip开启状态，取值['ENABLE','DISABLE']
        public let eipStatus: String

        public init(eipStatus: String) {
            self.eipStatus = eipStatus
        }

        enum CodingKeys: String, CodingKey {
            case eipStatus = "EipStatus"
        }
    }

    /// 公网访问固定ip配置
    public struct EipConfigOut: TCOutputModel {
        /// 是否是固定IP，["ENABLE","DISABLE"]
        public let eipStatus: String

        /// IP列表
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let eipAddress: [String]?

        enum CodingKeys: String, CodingKey {
            case eipStatus = "EipStatus"
            case eipAddress = "EipAddress"
        }
    }

    /// EipOutConfig
    public struct EipOutConfig: TCOutputModel {
        /// 是否是固定IP，["TRUE","FALSE"]
        public let eipFixed: String

        /// IP列表
        public let eips: [String]

        enum CodingKeys: String, CodingKey {
            case eipFixed = "EipFixed"
            case eips = "Eips"
        }
    }

    /// 函数的环境变量参数
    public struct Environment: TCInputModel {
        /// 环境变量数组
        public let variables: [Variable]?

        public init(variables: [Variable]? = nil) {
            self.variables = variables
        }

        enum CodingKeys: String, CodingKey {
            case variables = "Variables"
        }
    }

    /// 描述键值对过滤器，用于条件过滤查询。例如过滤ID、名称、状态等
    /// 若存在多个Filter时，Filter间的关系为逻辑与（AND）关系。
    /// 若同一个Filter存在多个Values，同一Filter下Values间的关系为逻辑或（OR）关系。
    public struct Filter: TCInputModel {
        /// 需要过滤的字段。过滤条件数量限制为10。
        /// Name可选值：VpcId, SubnetId, ClsTopicId, ClsLogsetId, Role, CfsId, CfsMountInsId, Eip；Values 长度限制为1。
        /// Name可选值：Status, Runtime, FunctionType, PublicNetStatus, AsyncRunEnable, TraceEnable；Values 长度限制为20。
        /// 当 Name = Runtime 时，CustomImage 表示过滤镜像类型函数。
        public let name: String

        /// 字段的过滤值。
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    /// 函数列表
    public struct Function: TCOutputModel {
        /// 修改时间
        public let modTime: String

        /// 创建时间
        public let addTime: String

        /// 运行时
        public let runtime: String

        /// 函数名称
        public let functionName: String

        /// 函数ID
        public let functionId: String

        /// 命名空间
        public let namespace: String

        /// 函数状态，状态值及流转[参考此处](https://cloud.tencent.com/document/product/583/47175)
        public let status: String

        /// 函数状态详情
        public let statusDesc: String

        /// 函数描述
        public let description: String

        /// 函数标签
        public let tags: [Tag]

        /// 函数类型，取值为 HTTP 或者 Event
        public let type: String

        /// 函数状态失败原因
        public let statusReasons: [StatusReason]

        /// 函数所有版本预置并发内存总和
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let totalProvisionedConcurrencyMem: UInt64?

        /// 函数并发保留内存
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let reservedConcurrencyMem: UInt64?

        /// 函数异步属性，取值 TRUE 或者 FALSE
        public let asyncRunEnable: String

        /// 异步函数是否开启调用追踪，取值 TRUE 或者 FALSE
        public let traceEnable: String

        enum CodingKeys: String, CodingKey {
            case modTime = "ModTime"
            case addTime = "AddTime"
            case runtime = "Runtime"
            case functionName = "FunctionName"
            case functionId = "FunctionId"
            case namespace = "Namespace"
            case status = "Status"
            case statusDesc = "StatusDesc"
            case description = "Description"
            case tags = "Tags"
            case type = "Type"
            case statusReasons = "StatusReasons"
            case totalProvisionedConcurrencyMem = "TotalProvisionedConcurrencyMem"
            case reservedConcurrencyMem = "ReservedConcurrencyMem"
            case asyncRunEnable = "AsyncRunEnable"
            case traceEnable = "TraceEnable"
        }
    }

    /// 日志信息
    public struct FunctionLog: TCOutputModel {
        /// 函数的名称
        public let functionName: String

        /// 函数执行完成后的返回值
        public let retMsg: String

        /// 执行该函数对应的requestId
        public let requestId: String

        /// 函数开始执行时的时间点
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var startTime: Date

        /// 函数执行结果，如果是 0 表示执行成功，其他值表示失败
        public let retCode: Int64

        /// 函数调用是否结束，如果是 1 表示执行结束，其他值表示调用异常
        public let invokeFinished: Int64

        /// 函数执行耗时，单位为 ms
        public let duration: Float

        /// 函数计费时间，根据 duration 向上取最近的 100ms，单位为ms
        public let billDuration: Int64

        /// 函数执行时消耗实际内存大小，单位为 Byte
        public let memUsage: Int64

        /// 函数执行过程中的日志输出
        public let log: String

        /// 日志等级
        public let level: String

        /// 日志来源
        public let source: String

        /// 重试次数
        public let retryNum: UInt64

        enum CodingKeys: String, CodingKey {
            case functionName = "FunctionName"
            case retMsg = "RetMsg"
            case requestId = "RequestId"
            case startTime = "StartTime"
            case retCode = "RetCode"
            case invokeFinished = "InvokeFinished"
            case duration = "Duration"
            case billDuration = "BillDuration"
            case memUsage = "MemUsage"
            case log = "Log"
            case level = "Level"
            case source = "Source"
            case retryNum = "RetryNum"
        }
    }

    /// 函数版本信息
    public struct FunctionVersion: TCInputModel, TCOutputModel {
        /// 函数版本名称
        public let version: String

        /// 版本描述信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let description: String?

        /// 创建时间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var addTime: Date?

        /// 更新时间
        /// 注意：此字段可能返回 null，表示取不到有效值。
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var modTime: Date?

        /// 版本状态
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let status: String?

        public init(version: String, description: String? = nil, addTime: Date? = nil, modTime: Date? = nil, status: String? = nil) {
            self.version = version
            self.description = description
            self._addTime = .init(wrappedValue: addTime)
            self._modTime = .init(wrappedValue: modTime)
            self.status = status
        }

        enum CodingKeys: String, CodingKey {
            case version = "Version"
            case description = "Description"
            case addTime = "AddTime"
            case modTime = "ModTime"
            case status = "Status"
        }
    }

    /// TCR镜像信息描述
    public struct ImageConfig: TCInputModel, TCOutputModel {
        /// 镜像仓库类型，个人版或者企业版：personal/enterprise
        public let imageType: String

        /// {domain}/{namespace}/{imageName}:{tag}@{digest}
        public let imageUri: String

        /// 用于企业版TCR获取镜像拉取临时凭证，ImageType为"enterprise"时必填
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let registryId: String?

        /// 参数已废弃
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let entryPoint: String?

        /// 容器的启动命令。该参数为可选参数，如果不填写，则默认使用 Dockerfile 中的 Entrypoint。传入规范，填写可运行的指令，例如 python
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let command: String?

        /// 容器的启动参数。该参数为可选参数，如果不填写，则默认使用 Dockerfile 中的 CMD。传入规范，以“空格”作为参数的分割标识，例如 -u app.py
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let args: String?

        /// 镜像加速开关，默认False
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let containerImageAccelerate: Bool?

        public init(imageType: String, imageUri: String, registryId: String? = nil, entryPoint: String? = nil, command: String? = nil, args: String? = nil, containerImageAccelerate: Bool? = nil) {
            self.imageType = imageType
            self.imageUri = imageUri
            self.registryId = registryId
            self.entryPoint = entryPoint
            self.command = command
            self.args = args
            self.containerImageAccelerate = containerImageAccelerate
        }

        enum CodingKeys: String, CodingKey {
            case imageType = "ImageType"
            case imageUri = "ImageUri"
            case registryId = "RegistryId"
            case entryPoint = "EntryPoint"
            case command = "Command"
            case args = "Args"
            case containerImageAccelerate = "ContainerImageAccelerate"
        }
    }

    /// 多并发执行配置描述
    public struct InstanceConcurrencyConfig: TCInputModel, TCOutputModel {
        /// 是否开启智能动态并发。'FALSE'时是静态并发。''时取消多并发配置。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let dynamicEnabled: String?

        /// 单实例并发数最大值。取值范围 [1,100]
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let maxConcurrency: UInt64?

        public init(dynamicEnabled: String? = nil, maxConcurrency: UInt64? = nil) {
            self.dynamicEnabled = dynamicEnabled
            self.maxConcurrency = maxConcurrency
        }

        enum CodingKeys: String, CodingKey {
            case dynamicEnabled = "DynamicEnabled"
            case maxConcurrency = "MaxConcurrency"
        }
    }

    /// 层版本信息
    public struct LayerVersionInfo: TCOutputModel {
        /// 版本适用的运行时
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let compatibleRuntimes: [String]?

        /// 创建时间
        public let addTime: String?

        /// 版本描述
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let description: String?

        /// 许可证信息
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let licenseInfo: String?

        /// 版本号
        public let layerVersion: Int64

        /// 层名称
        public let layerName: String

        /// 层的具体版本当前状态，状态值[参考此处](https://cloud.tencent.com/document/product/583/47175#.E5.B1.82.EF.BC.88layer.EF.BC.89.E7.8A.B6.E6.80.81)
        public let status: String?

        enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case addTime = "AddTime"
            case description = "Description"
            case licenseInfo = "LicenseInfo"
            case layerVersion = "LayerVersion"
            case layerName = "LayerName"
            case status = "Status"
        }
    }

    /// 指定某个Layer版本
    public struct LayerVersionSimple: TCInputModel, TCOutputModel {
        /// 绑定的层名称。解绑层需传递空字符串。
        public let layerName: String

        /// 绑定或解绑层的版本号。解绑函数版本关联的最后一个层版本时，LayerVersion 填 0。
        public let layerVersion: Int64

        public init(layerName: String, layerVersion: Int64) {
            self.layerName = layerName
            self.layerVersion = layerVersion
        }

        enum CodingKeys: String, CodingKey {
            case layerName = "LayerName"
            case layerVersion = "LayerVersion"
        }
    }

    /// 限制信息
    public struct LimitsInfo: TCOutputModel {
        /// 命名空间个数限制
        public let namespacesCount: Int64

        /// 命名空间限制信息
        public let namespace: [NamespaceLimit]

        enum CodingKeys: String, CodingKey {
            case namespacesCount = "NamespacesCount"
            case namespace = "Namespace"
        }
    }

    /// 日志过滤条件，用于区分正确与错误日志
    public struct LogFilter: TCInputModel {
        /// filter.RetCode的取值有：
        /// not0 表示只返回错误日志，
        /// is0 表示只返回正确日志，
        /// TimeLimitExceeded 返回函数调用发生超时的日志，
        /// ResourceLimitExceeded 返回函数调用发生资源超限的日志，
        /// UserCodeException 返回函数调用发生用户代码错误的日志，
        /// 无输入则返回所有日志。
        public let retCode: String?

        public init(retCode: String? = nil) {
            self.retCode = retCode
        }

        enum CodingKeys: String, CodingKey {
            case retCode = "RetCode"
        }
    }

    /// 日志搜索上下文
    public struct LogSearchContext: TCInputModel, TCOutputModel {
        /// 偏移量
        public let offset: String

        /// 日志条数
        public let limit: UInt64

        /// 日志关键词
        public let keyword: String?

        /// 日志类型，支持Application和Platform，默认为Application
        public let type: String?

        public init(offset: String, limit: UInt64, keyword: String? = nil, type: String? = nil) {
            self.offset = offset
            self.limit = limit
            self.keyword = keyword
            self.type = type
        }

        enum CodingKeys: String, CodingKey {
            case offset = "Offset"
            case limit = "Limit"
            case keyword = "Keyword"
            case type = "Type"
        }
    }

    /// 命名空间
    public struct Namespace: TCOutputModel {
        /// 命名空间创建时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var modTime: Date

        /// 命名空间修改时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var addTime: Date

        /// 命名空间描述
        public let description: String

        /// 命名空间名称
        public let name: String

        /// 默认default，TCB表示是小程序云开发创建的
        public let type: String

        enum CodingKeys: String, CodingKey {
            case modTime = "ModTime"
            case addTime = "AddTime"
            case description = "Description"
            case name = "Name"
            case type = "Type"
        }
    }

    /// 命名空间限制
    public struct NamespaceLimit: TCOutputModel {
        /// 函数总数
        public let functionsCount: Int64

        /// Trigger信息
        public let trigger: TriggerCount

        /// Namespace名称
        public let namespace: String

        /// 并发量
        public let concurrentExecutions: Int64

        /// Timeout限制
        public let timeoutLimit: Int64

        /// 测试事件限制
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let testModelLimit: Int64?

        /// 初始化超时限制
        public let initTimeoutLimit: Int64

        /// 异步重试次数限制
        public let retryNumLimit: Int64

        /// 异步重试消息保留时间下限
        public let minMsgTTL: Int64

        /// 异步重试消息保留时间上限
        public let maxMsgTTL: Int64

        enum CodingKeys: String, CodingKey {
            case functionsCount = "FunctionsCount"
            case trigger = "Trigger"
            case namespace = "Namespace"
            case concurrentExecutions = "ConcurrentExecutions"
            case timeoutLimit = "TimeoutLimit"
            case testModelLimit = "TestModelLimit"
            case initTimeoutLimit = "InitTimeoutLimit"
            case retryNumLimit = "RetryNumLimit"
            case minMsgTTL = "MinMsgTTL"
            case maxMsgTTL = "MaxMsgTTL"
        }
    }

    /// 名称空间已使用信息
    public struct NamespaceUsage: TCOutputModel {
        /// 函数数组
        public let functions: [String]

        /// 命名空间名称
        public let namespace: String

        /// 命名空间函数个数
        public let functionsCount: Int64

        /// 命名空间配额总量
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let totalConcurrencyMem: Int64?

        /// 命名空间并发使用量
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let totalAllocatedConcurrencyMem: Int64?

        /// 命名空间预置使用量
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let totalAllocatedProvisionedMem: Int64?

        enum CodingKeys: String, CodingKey {
            case functions = "Functions"
            case namespace = "Namespace"
            case functionsCount = "FunctionsCount"
            case totalConcurrencyMem = "TotalConcurrencyMem"
            case totalAllocatedConcurrencyMem = "TotalAllocatedConcurrencyMem"
            case totalAllocatedProvisionedMem = "TotalAllocatedProvisionedMem"
        }
    }

    /// HTTP函数支持其他访问协议的参数
    public struct ProtocolParams: TCInputModel, TCOutputModel {
        /// WebSockets协议支持的参数
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let wsParams: WSParams?

        public init(wsParams: WSParams? = nil) {
            self.wsParams = wsParams
        }

        enum CodingKeys: String, CodingKey {
            case wsParams = "WSParams"
        }
    }

    /// 公网访问配置
    public struct PublicNetConfigIn: TCInputModel {
        /// 是否开启公网访问能力取值['DISABLE','ENABLE']
        public let publicNetStatus: String

        /// Eip配置
        public let eipConfig: EipConfigIn?

        public init(publicNetStatus: String, eipConfig: EipConfigIn? = nil) {
            self.publicNetStatus = publicNetStatus
            self.eipConfig = eipConfig
        }

        enum CodingKeys: String, CodingKey {
            case publicNetStatus = "PublicNetStatus"
            case eipConfig = "EipConfig"
        }
    }

    /// 公网访问配置
    public struct PublicNetConfigOut: TCOutputModel {
        /// 是否开启公网访问能力取值['DISABLE','ENABLE']
        public let publicNetStatus: String

        /// Eip配置
        public let eipConfig: EipConfigOut

        enum CodingKeys: String, CodingKey {
            case publicNetStatus = "PublicNetStatus"
            case eipConfig = "EipConfig"
        }
    }

    /// 函数运行状态
    public struct RequestStatus: TCOutputModel {
        /// 函数的名称
        public let functionName: String

        /// 函数执行完成后的返回值
        public let retMsg: String

        /// 查询的请求 id
        public let requestId: String

        /// 请求开始时间
        public let startTime: String

        /// 请求执行结果， 0 表示执行成功，1表示运行中，-1 表示执行异常。
        public let retCode: Int64

        /// 请求运行耗时，单位：ms
        public let duration: Float

        /// 请求消耗内存，单位为 MB
        public let memUsage: Float

        /// 重试次数
        public let retryNum: Int64

        enum CodingKeys: String, CodingKey {
            case functionName = "FunctionName"
            case retMsg = "RetMsg"
            case requestId = "RequestId"
            case startTime = "StartTime"
            case retCode = "RetCode"
            case duration = "Duration"
            case memUsage = "MemUsage"
            case retryNum = "RetryNum"
        }
    }

    /// 运行函数的返回
    public struct Result: TCOutputModel {
        /// 表示执行过程中的日志输出，异步调用返回为空
        public let log: String

        /// 表示执行函数的返回，异步调用返回为空
        public let retMsg: String

        /// 表示执行函数的错误返回信息，异步调用返回为空
        public let errMsg: String

        /// 执行函数时的内存大小，单位为Byte，异步调用返回为空
        public let memUsage: Int64

        /// 表示执行函数的耗时，单位是毫秒，异步调用返回为空
        public let duration: Float

        /// 表示函数的计费耗时，单位是毫秒，异步调用返回为空
        public let billDuration: Int64

        /// 此次函数执行的Id
        public let functionRequestId: String

        /// 0为正确，异步调用返回为空
        public let invokeResult: Int64

        enum CodingKeys: String, CodingKey {
            case log = "Log"
            case retMsg = "RetMsg"
            case errMsg = "ErrMsg"
            case memUsage = "MemUsage"
            case duration = "Duration"
            case billDuration = "BillDuration"
            case functionRequestId = "FunctionRequestId"
            case invokeResult = "InvokeResult"
        }
    }

    /// 异步重试配置
    public struct RetryConfig: TCInputModel, TCOutputModel {
        /// 重试次数
        public let retryNum: Int64

        public init(retryNum: Int64) {
            self.retryNum = retryNum
        }

        enum CodingKeys: String, CodingKey {
            case retryNum = "RetryNum"
        }
    }

    /// 别名的版本路由配置
    public struct RoutingConfig: TCInputModel, TCOutputModel {
        /// 随机权重路由附加版本
        public let additionalVersionWeights: [VersionWeight]?

        /// 规则路由附加版本
        public let addtionVersionMatchs: [VersionMatch]?

        public init(additionalVersionWeights: [VersionWeight]? = nil, addtionVersionMatchs: [VersionMatch]? = nil) {
            self.additionalVersionWeights = additionalVersionWeights
            self.addtionVersionMatchs = addtionVersionMatchs
        }

        enum CodingKeys: String, CodingKey {
            case additionalVersionWeights = "AdditionalVersionWeights"
            case addtionVersionMatchs = "AddtionVersionMatchs"
        }
    }

    /// 包含搜索关键字和对应的内容
    public struct SearchKey: TCInputModel {
        /// 搜索关键字
        public let key: String

        /// 搜索内容
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// 状态原因描述
    public struct StatusReason: TCOutputModel {
        /// 错误码
        public let errorCode: String

        /// 错误描述
        public let errorMessage: String

        enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    /// 函数标签
    public struct Tag: TCInputModel, TCOutputModel {
        /// 标签的key
        public let key: String

        /// 标签的value
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// 左闭右开时间区间，包括起始时间和结束时间，格式为"%Y-%m-%d %H:%M:%S"
    public struct TimeInterval: TCInputModel {
        /// 起始时间（包括在内），格式"%Y-%m-%d %H:%M:%S"
        public let start: String

        /// 结束时间（不包括在内），格式"%Y-%m-%d %H:%M:%S"
        public let end: String

        public init(start: String, end: String) {
            self.start = start
            self.end = end
        }

        enum CodingKeys: String, CodingKey {
            case start = "Start"
            case end = "End"
        }
    }

    /// 触发器类型
    public struct Trigger: TCOutputModel {
        /// 触发器最后修改时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var modTime: Date

        /// 触发器类型
        public let type: String

        /// 触发器详细配置
        public let triggerDesc: String

        /// 触发器名称
        public let triggerName: String

        /// 触发器创建时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var addTime: Date

        /// 使能开关
        public let enable: Int64

        /// 客户自定义参数
        public let customArgument: String

        /// 触发器状态
        public let availableStatus: String

        /// 触发器最小资源ID
        public let resourceId: String

        /// 触发器和云函数绑定状态
        public let bindStatus: String

        /// 触发器类型，双向表示两侧控制台均可操作，单向表示SCF控制台单向创建
        public let triggerAttribute: String

        /// 触发器绑定的别名或版本
        public let qualifier: String

        enum CodingKeys: String, CodingKey {
            case modTime = "ModTime"
            case type = "Type"
            case triggerDesc = "TriggerDesc"
            case triggerName = "TriggerName"
            case addTime = "AddTime"
            case enable = "Enable"
            case customArgument = "CustomArgument"
            case availableStatus = "AvailableStatus"
            case resourceId = "ResourceId"
            case bindStatus = "BindStatus"
            case triggerAttribute = "TriggerAttribute"
            case qualifier = "Qualifier"
        }
    }

    /// 预置定时任务动作
    public struct TriggerAction: TCInputModel, TCOutputModel {
        /// 定时预置名称
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let triggerName: String?

        /// 定时预置并发数量
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let triggerProvisionedConcurrencyNum: UInt64?

        /// 设置定时触发器的时间配置，cron表达式。Cron 表达式有七个必需字段，按空格分隔。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let triggerCronConfig: String?

        /// 预置类型 Default
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let provisionedType: String?

        public init(triggerName: String, triggerProvisionedConcurrencyNum: UInt64, triggerCronConfig: String, provisionedType: String? = nil) {
            self.triggerName = triggerName
            self.triggerProvisionedConcurrencyNum = triggerProvisionedConcurrencyNum
            self.triggerCronConfig = triggerCronConfig
            self.provisionedType = provisionedType
        }

        enum CodingKeys: String, CodingKey {
            case triggerName = "TriggerName"
            case triggerProvisionedConcurrencyNum = "TriggerProvisionedConcurrencyNum"
            case triggerCronConfig = "TriggerCronConfig"
            case provisionedType = "ProvisionedType"
        }
    }

    /// TriggerCount描述不同类型触发器的数量
    public struct TriggerCount: TCOutputModel {
        /// Cos触发器数量
        public let cos: Int64

        /// Timer触发器数量
        public let timer: Int64

        /// Cmq触发器数量
        public let cmq: Int64

        /// 触发器总数
        public let total: Int64

        /// Ckafka触发器数量
        public let ckafka: Int64

        /// Apigw触发器数量
        public let apigw: Int64

        /// Cls触发器数量
        public let cls: Int64

        /// Clb触发器数量
        public let clb: Int64

        /// Mps触发器数量
        public let mps: Int64

        /// Cm触发器数量
        public let cm: Int64

        /// Vod触发器数量
        public let vod: Int64

        enum CodingKeys: String, CodingKey {
            case cos = "Cos"
            case timer = "Timer"
            case cmq = "Cmq"
            case total = "Total"
            case ckafka = "Ckafka"
            case apigw = "Apigw"
            case cls = "Cls"
            case clb = "Clb"
            case mps = "Mps"
            case cm = "Cm"
            case vod = "Vod"
        }
    }

    /// 触发器信息
    public struct TriggerInfo: TCOutputModel {
        /// 使能开关
        public let enable: UInt64

        /// 函数版本或别名
        public let qualifier: String

        /// 触发器名称
        public let triggerName: String

        /// 触发器类型
        public let type: String

        /// 触发器详细配置
        public let triggerDesc: String

        /// 触发器是否可用
        public let availableStatus: String

        /// 客户自定义参数
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let customArgument: String?

        /// 触发器创建时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var addTime: Date

        /// 触发器最后修改时间
        ///
        /// While the wrapped date value is immutable just like other fields, you can customize the projected
        /// string value (through `$`-prefix) in case the synthesized encoding is incorrect.
        @TCTimestampEncoding public var modTime: Date

        /// 触发器最小资源ID
        public let resourceId: String

        /// 触发器和云函数绑定状态
        public let bindStatus: String

        /// 触发器类型，双向表示两侧控制台均可操作，单向表示SCF控制台单向创建
        public let triggerAttribute: String

        enum CodingKeys: String, CodingKey {
            case enable = "Enable"
            case qualifier = "Qualifier"
            case triggerName = "TriggerName"
            case type = "Type"
            case triggerDesc = "TriggerDesc"
            case availableStatus = "AvailableStatus"
            case customArgument = "CustomArgument"
            case addTime = "AddTime"
            case modTime = "ModTime"
            case resourceId = "ResourceId"
            case bindStatus = "BindStatus"
            case triggerAttribute = "TriggerAttribute"
        }
    }

    /// 已使用的信息
    public struct UsageInfo: TCOutputModel {
        /// 命名空间个数
        public let namespacesCount: Int64

        /// 命名空间详情
        public let namespace: [NamespaceUsage]

        /// 当前地域用户并发内存配额上限
        public let totalConcurrencyMem: Int64

        /// 当前地域用户已配置并发内存额度
        public let totalAllocatedConcurrencyMem: Int64

        /// 用户实际配置的账号并发配额
        public let userConcurrencyMemLimit: Int64

        enum CodingKeys: String, CodingKey {
            case namespacesCount = "NamespacesCount"
            case namespace = "Namespace"
            case totalConcurrencyMem = "TotalConcurrencyMem"
            case totalAllocatedConcurrencyMem = "TotalAllocatedConcurrencyMem"
            case userConcurrencyMemLimit = "UserConcurrencyMemLimit"
        }
    }

    /// 变量参数
    public struct Variable: TCInputModel {
        /// 变量的名称，不可为空字符
        public let key: String?

        /// 变量的值，不可为空字符
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    /// 带有匹配规则的函数版本
    public struct VersionMatch: TCInputModel, TCOutputModel {
        /// 函数版本名称
        public let version: String

        /// 匹配规则的key，调用时通过传key来匹配规则路由到指定版本
        /// header方式：
        /// key填写"invoke.headers.User"，并在 invoke 调用函数时传参 RoutingKey：{"User":"value"}规则匹配调用
        public let key: String

        /// 匹配方式。取值范围：
        /// range：范围匹配
        /// exact：字符串精确匹配
        public let method: String

        /// range 匹配规则要求：
        /// 需要为开区间或闭区间描述 (a,b) [a,b]，其中 a、b 均为整数
        /// exact 匹配规则要求：
        /// 字符串精确匹配
        public let expression: String

        public init(version: String, key: String, method: String, expression: String) {
            self.version = version
            self.key = key
            self.method = method
            self.expression = expression
        }

        enum CodingKeys: String, CodingKey {
            case version = "Version"
            case key = "Key"
            case method = "Method"
            case expression = "Expression"
        }
    }

    /// 函数版本的预置并发信息，包括设置预置并发数、已完成预置的并发数和预置任务状态。
    public struct VersionProvisionedConcurrencyInfo: TCOutputModel {
        /// 设置的预置并发数。
        public let allocatedProvisionedConcurrencyNum: UInt64

        /// 当前已完成预置的并发数。
        public let availableProvisionedConcurrencyNum: UInt64

        /// 预置任务状态，Done表示已完成，InProgress表示进行中，Failed表示部分或全部失败。
        public let status: String

        /// 对预置任务状态Status的说明。
        public let statusReason: String

        /// 函数版本号
        public let qualifier: String

        /// 预置并发定时任务。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let triggerActions: [TriggerAction]?

        enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrencyNum = "AllocatedProvisionedConcurrencyNum"
            case availableProvisionedConcurrencyNum = "AvailableProvisionedConcurrencyNum"
            case status = "Status"
            case statusReason = "StatusReason"
            case qualifier = "Qualifier"
            case triggerActions = "TriggerActions"
        }
    }

    /// 带有权重的函数版本
    public struct VersionWeight: TCInputModel, TCOutputModel {
        /// 函数版本名称
        public let version: String

        /// 该版本的权重
        public let weight: Float

        public init(version: String, weight: Float) {
            self.version = version
            self.weight = weight
        }

        enum CodingKeys: String, CodingKey {
            case version = "Version"
            case weight = "Weight"
        }
    }

    /// 私有网络参数配置
    public struct VpcConfig: TCInputModel {
        /// 私有网络 的 Id
        public let vpcId: String?

        /// 子网的 Id
        public let subnetId: String?

        public init(vpcId: String? = nil, subnetId: String? = nil) {
            self.vpcId = vpcId
            self.subnetId = subnetId
        }

        enum CodingKeys: String, CodingKey {
            case vpcId = "VpcId"
            case subnetId = "SubnetId"
        }
    }

    /// HTTP函数通过WebSockets协议访问时的参数
    public struct WSParams: TCInputModel, TCOutputModel {
        /// 空闲超时时间, 单位秒，默认15s。可配置范围1~1800s。
        /// 注意：此字段可能返回 null，表示取不到有效值。
        public let idleTimeOut: UInt64?

        public init(idleTimeOut: UInt64? = nil) {
            self.idleTimeOut = idleTimeOut
        }

        enum CodingKeys: String, CodingKey {
            case idleTimeOut = "IdleTimeOut"
        }
    }
}
