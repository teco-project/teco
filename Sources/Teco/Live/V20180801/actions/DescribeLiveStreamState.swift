//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project.
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

extension Live {
    /// DescribeLiveStreamState请求参数结构体
    public struct DescribeLiveStreamStateRequest: TCRequestModel {
        /// 推流路径，与推流和播放地址中的AppName保持一致，默认为 live。
        public let appName: String

        /// 您的推流域名。
        public let domainName: String

        /// 流名称。
        public let streamName: String

        public init(appName: String, domainName: String, streamName: String) {
            self.appName = appName
            self.domainName = domainName
            self.streamName = streamName
        }

        enum CodingKeys: String, CodingKey {
            case appName = "AppName"
            case domainName = "DomainName"
            case streamName = "StreamName"
        }
    }

    /// DescribeLiveStreamState返回参数结构体
    public struct DescribeLiveStreamStateResponse: TCResponseModel {
        /// 流状态，
        /// active：活跃，
        /// inactive：非活跃，
        /// forbid：禁播。
        public let streamState: String

        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case streamState = "StreamState"
            case requestId = "RequestId"
        }
    }

    /// 查询流状态
    ///
    /// 返回直播中、无推流或者禁播等状态。
    /// 使用建议：
    /// 该接口提供实时流状态查询功能，鉴于网络抖动等一些不可抗因素，使用该接口作为判断主播是否开播等重要业务场景时，请参考以下使用建议。
    /// 1. 优先使用业务自身的房间开关播逻辑，判断主播是否在线，譬如客户端开播信令和主播在线心跳等。
    /// 2. 对于没有房间管理的直播场景，可以结合以下方案综合判断。
    /// 2.1 根据[推断流事件通知](/document/product/267/20388) 判断主播在线状态。
    /// 2.2 通过定时（间隔>1min）查询[直播中的流接口](/document/api/267/20472)，判断主播是否在线。
    /// 2.3 通过 本接口 查询直播流状态，判断主播是否在线。
    /// 2.4 以上任一方式判断为在线，都认为主播开播中，并且接口查询超时或解析异常时，也默认为在线，减少对业务的影响。
    @inlinable
    public func describeLiveStreamState(_ input: DescribeLiveStreamStateRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeLiveStreamStateResponse> {
        self.client.execute(action: "DescribeLiveStreamState", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 查询流状态
    ///
    /// 返回直播中、无推流或者禁播等状态。
    /// 使用建议：
    /// 该接口提供实时流状态查询功能，鉴于网络抖动等一些不可抗因素，使用该接口作为判断主播是否开播等重要业务场景时，请参考以下使用建议。
    /// 1. 优先使用业务自身的房间开关播逻辑，判断主播是否在线，譬如客户端开播信令和主播在线心跳等。
    /// 2. 对于没有房间管理的直播场景，可以结合以下方案综合判断。
    /// 2.1 根据[推断流事件通知](/document/product/267/20388) 判断主播在线状态。
    /// 2.2 通过定时（间隔>1min）查询[直播中的流接口](/document/api/267/20472)，判断主播是否在线。
    /// 2.3 通过 本接口 查询直播流状态，判断主播是否在线。
    /// 2.4 以上任一方式判断为在线，都认为主播开播中，并且接口查询超时或解析异常时，也默认为在线，减少对业务的影响。
    @inlinable
    public func describeLiveStreamState(_ input: DescribeLiveStreamStateRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DescribeLiveStreamStateResponse {
        try await self.client.execute(action: "DescribeLiveStreamState", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 查询流状态
    ///
    /// 返回直播中、无推流或者禁播等状态。
    /// 使用建议：
    /// 该接口提供实时流状态查询功能，鉴于网络抖动等一些不可抗因素，使用该接口作为判断主播是否开播等重要业务场景时，请参考以下使用建议。
    /// 1. 优先使用业务自身的房间开关播逻辑，判断主播是否在线，譬如客户端开播信令和主播在线心跳等。
    /// 2. 对于没有房间管理的直播场景，可以结合以下方案综合判断。
    /// 2.1 根据[推断流事件通知](/document/product/267/20388) 判断主播在线状态。
    /// 2.2 通过定时（间隔>1min）查询[直播中的流接口](/document/api/267/20472)，判断主播是否在线。
    /// 2.3 通过 本接口 查询直播流状态，判断主播是否在线。
    /// 2.4 以上任一方式判断为在线，都认为主播开播中，并且接口查询超时或解析异常时，也默认为在线，减少对业务的影响。
    @inlinable
    public func describeLiveStreamState(appName: String, domainName: String, streamName: String, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeLiveStreamStateResponse> {
        self.describeLiveStreamState(DescribeLiveStreamStateRequest(appName: appName, domainName: domainName, streamName: streamName), region: region, logger: logger, on: eventLoop)
    }

    /// 查询流状态
    ///
    /// 返回直播中、无推流或者禁播等状态。
    /// 使用建议：
    /// 该接口提供实时流状态查询功能，鉴于网络抖动等一些不可抗因素，使用该接口作为判断主播是否开播等重要业务场景时，请参考以下使用建议。
    /// 1. 优先使用业务自身的房间开关播逻辑，判断主播是否在线，譬如客户端开播信令和主播在线心跳等。
    /// 2. 对于没有房间管理的直播场景，可以结合以下方案综合判断。
    /// 2.1 根据[推断流事件通知](/document/product/267/20388) 判断主播在线状态。
    /// 2.2 通过定时（间隔>1min）查询[直播中的流接口](/document/api/267/20472)，判断主播是否在线。
    /// 2.3 通过 本接口 查询直播流状态，判断主播是否在线。
    /// 2.4 以上任一方式判断为在线，都认为主播开播中，并且接口查询超时或解析异常时，也默认为在线，减少对业务的影响。
    @inlinable
    public func describeLiveStreamState(appName: String, domainName: String, streamName: String, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DescribeLiveStreamStateResponse {
        try await self.describeLiveStreamState(DescribeLiveStreamStateRequest(appName: appName, domainName: domainName, streamName: streamName), region: region, logger: logger, on: eventLoop)
    }
}
