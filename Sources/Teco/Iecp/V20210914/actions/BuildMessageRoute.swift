//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

// Test PR teco-project/teco-code-generator#23.

import Logging
import NIOCore
import TecoCore

extension Iecp {
    /// BuildMessageRoute请求参数结构体
    public struct BuildMessageRouteRequest: TCRequestModel {
        /// 路由名字
        public let routeName: String

        /// 源产品id
        public let sourceProductID: String

        /// 源设备名列表
        public let sourceDeviceNameList: [String]

        /// 第一个字符为 "0"或"1"，"1"表示自定义topic
        public let topicFilter: String

        /// http或mqtt-broker
        public let mode: String

        /// 源单元id列表
        public let sourceUnitIDList: [String]?

        /// 描述
        public let descript: String?

        /// 无
        public let targetOptions: String?

        public init(routeName: String, sourceProductID: String, sourceDeviceNameList: [String], topicFilter: String, mode: String, sourceUnitIDList: [String]? = nil, descript: String? = nil, targetOptions: String? = nil) {
            self.routeName = routeName
            self.sourceProductID = sourceProductID
            self.sourceDeviceNameList = sourceDeviceNameList
            self.topicFilter = topicFilter
            self.mode = mode
            self.sourceUnitIDList = sourceUnitIDList
            self.descript = descript
            self.targetOptions = targetOptions
        }

        enum CodingKeys: String, CodingKey {
            case routeName = "RouteName"
            case sourceProductID = "SourceProductID"
            case sourceDeviceNameList = "SourceDeviceNameList"
            case topicFilter = "TopicFilter"
            case mode = "Mode"
            case sourceUnitIDList = "SourceUnitIDList"
            case descript = "Descript"
            case targetOptions = "TargetOptions"
        }
    }

    /// BuildMessageRoute返回参数结构体
    public struct BuildMessageRouteResponse: TCResponseModel {
        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    /// 建立消息路由
    @inlinable @discardableResult
    public func buildMessageRoute(_ input: BuildMessageRouteRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BuildMessageRouteResponse> {
        self.client.execute(action: "BuildMessageRoute", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 建立消息路由
    @inlinable @discardableResult
    public func buildMessageRoute(_ input: BuildMessageRouteRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BuildMessageRouteResponse {
        try await self.client.execute(action: "BuildMessageRoute", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 建立消息路由
    @inlinable @discardableResult
    public func buildMessageRoute(routeName: String, sourceProductID: String, sourceDeviceNameList: [String], topicFilter: String, mode: String, sourceUnitIDList: [String]? = nil, descript: String? = nil, targetOptions: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BuildMessageRouteResponse> {
        self.buildMessageRoute(.init(routeName: routeName, sourceProductID: sourceProductID, sourceDeviceNameList: sourceDeviceNameList, topicFilter: topicFilter, mode: mode, sourceUnitIDList: sourceUnitIDList, descript: descript, targetOptions: targetOptions), region: region, logger: logger, on: eventLoop)
    }

    /// 建立消息路由
    @inlinable @discardableResult
    public func buildMessageRoute(routeName: String, sourceProductID: String, sourceDeviceNameList: [String], topicFilter: String, mode: String, sourceUnitIDList: [String]? = nil, descript: String? = nil, targetOptions: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BuildMessageRouteResponse {
        try await self.buildMessageRoute(.init(routeName: routeName, sourceProductID: sourceProductID, sourceDeviceNameList: sourceDeviceNameList, topicFilter: topicFilter, mode: mode, sourceUnitIDList: sourceUnitIDList, descript: descript, targetOptions: targetOptions), region: region, logger: logger, on: eventLoop)
    }
}
