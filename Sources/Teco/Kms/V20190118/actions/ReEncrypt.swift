//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project.
//
// Copyright (c) 2022 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

extension Kms {
    /// 密文刷新
    ///
    /// 使用指定CMK对密文重新加密。
    @inlinable
    public func reEncrypt(_ input: ReEncryptRequest, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture < ReEncryptResponse > {
        self.client.execute(action: "ReEncrypt", serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
    
    /// 密文刷新
    ///
    /// 使用指定CMK对密文重新加密。
    @inlinable
    public func reEncrypt(_ input: ReEncryptRequest, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ReEncryptResponse {
        try await self.client.execute(action: "ReEncrypt", serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }
    
    /// ReEncrypt请求参数结构体
    public struct ReEncryptRequest: TCRequestModel {
        /// 需要重新加密的密文
        public let ciphertextBlob: String
        
        /// 重新加密使用的CMK，如果为空，则使用密文原有的CMK重新加密（若密钥没有轮换则密文不会刷新）
        public let destinationKeyId: String?
        
        /// CiphertextBlob 密文加密时使用的key/value对的json字符串。如果加密时未使用，则为空
        public let sourceEncryptionContext: String?
        
        /// 重新加密使用的key/value对的json字符串，如果使用该字段，则返回的新密文在解密时需要填入相同的字符串
        public let destinationEncryptionContext: String?
        
        public init (ciphertextBlob: String, destinationKeyId: String?, sourceEncryptionContext: String?, destinationEncryptionContext: String?) {
            self.ciphertextBlob = ciphertextBlob
            self.destinationKeyId = destinationKeyId
            self.sourceEncryptionContext = sourceEncryptionContext
            self.destinationEncryptionContext = destinationEncryptionContext
        }
        
        enum CodingKeys: String, CodingKey {
            case ciphertextBlob = "CiphertextBlob"
            case destinationKeyId = "DestinationKeyId"
            case sourceEncryptionContext = "SourceEncryptionContext"
            case destinationEncryptionContext = "DestinationEncryptionContext"
        }
    }
    
    /// ReEncrypt返回参数结构体
    public struct ReEncryptResponse: TCResponseModel {
        /// 重新加密后的密文
        public let ciphertextBlob: String
        
        /// 重新加密使用的CMK
        public let keyId: String
        
        /// 重新加密前密文使用的CMK
        public let sourceKeyId: String
        
        /// true表示密文已经重新加密。同一个CMK进行重加密，在密钥没有发生轮换的情况下不会进行实际重新加密操作，返回原密文
        public let reEncrypted: Bool
        
        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String
        
        enum CodingKeys: String, CodingKey {
            case ciphertextBlob = "CiphertextBlob"
            case keyId = "KeyId"
            case sourceKeyId = "SourceKeyId"
            case reEncrypted = "ReEncrypted"
            case requestId = "RequestId"
        }
    }
}
