//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

import Logging
import NIOCore
import TecoCore

extension Dlc {
    /// CreateDataEngine请求参数结构体
    public struct CreateDataEngineRequest: TCRequestModel {
        /// 引擎类型spark/presto
        public let engineType: String

        /// 虚拟集群名称
        public let dataEngineName: String

        /// 集群类型 spark_private/presto_private/presto_cu/spark_cu
        public let clusterType: String

        /// 计费模式 0=共享模式 1=按量计费 2=包年包月
        public let mode: Int64

        /// 是否自动启动集群
        public let autoResume: Bool

        /// 最小资源
        public let minClusters: Int64?

        /// 最大资源
        public let maxClusters: Int64?

        /// 是否为默认虚拟集群
        public let defaultDataEngine: Bool?

        /// VPC网段
        public let cidrBlock: String?

        /// 描述信息
        public let message: String?

        /// 集群规模
        public let size: Int64?

        /// 计费类型，后付费：0，预付费：1。当前只支持后付费，不填默认为后付费。
        public let payMode: Int64?

        /// 资源使用时长，后付费：固定填3600，预付费：最少填1，代表购买资源一个月，最长不超过120。默认3600
        public let timeSpan: Int64?

        /// 资源使用时长的单位，后付费：s，预付费：m。默认为s
        public let timeUnit: String?

        /// 资源的自动续费标志。后付费无需续费，固定填0；预付费下：0表示手动续费、1代表自动续费、2代表不续费，在0下如果是大客户，会自动帮大客户续费。默认为0
        public let autoRenew: Int64?

        /// 创建资源的时候需要绑定的标签信息
        public let tags: [TagInfo]?

        /// 是否自定挂起集群：false（默认）：不自动挂起、true：自动挂起
        public let autoSuspend: Bool?

        /// 定时启停集群策略：0（默认）：关闭定时策略、1：开启定时策略（注：定时启停策略与自动挂起策略互斥）
        public let crontabResumeSuspend: Int64?

        /// 定时启停策略，复杂类型：包含启停时间、挂起集群策略
        public let crontabResumeSuspendStrategy: CrontabResumeSuspendStrategy?

        /// 引擎执行任务类型，有效值：SQL/BATCH，默认为SQL
        public let engineExecType: String?

        /// 单个集群最大并发任务数，默认5
        public let maxConcurrency: Int64?

        /// 可容忍的排队时间，默认0。当任务排队的时间超过可容忍的时间时可能会触发扩容。如果该参数为0，则表示一旦有任务排队就可能立即触发扩容。
        public let tolerableQueueTime: Int64?

        /// 集群自动挂起时间，默认10分钟
        public let autoSuspendTime: Int64?

        /// 资源类型。Standard_CU：标准型；Memory_CU：内存型
        public let resourceType: String?

        /// 集群高级配置
        public let dataEngineConfigPairs: [DataEngineConfigPair]?

        /// 集群镜像版本名字。如SuperSQL-P 1.1;SuperSQL-S 3.2等,不传，默认创建最新镜像版本的集群
        public let imageVersionName: String?

        /// 主集群名称，创建容灾集群时指定
        public let mainClusterName: String?

        /// spark jar 包年包月集群是否开启弹性
        public let elasticSwitch: Bool?

        /// spark jar 包年包月集群弹性上限
        public let elasticLimit: Int64?

        /// spark作业集群session资源配置模板
        public let sessionResourceTemplate: SessionResourceTemplate?

        public init(engineType: String, dataEngineName: String, clusterType: String, mode: Int64, autoResume: Bool, minClusters: Int64? = nil, maxClusters: Int64? = nil, defaultDataEngine: Bool? = nil, cidrBlock: String? = nil, message: String? = nil, size: Int64? = nil, payMode: Int64? = nil, timeSpan: Int64? = nil, timeUnit: String? = nil, autoRenew: Int64? = nil, tags: [TagInfo]? = nil, autoSuspend: Bool? = nil, crontabResumeSuspend: Int64? = nil, crontabResumeSuspendStrategy: CrontabResumeSuspendStrategy? = nil, engineExecType: String? = nil, maxConcurrency: Int64? = nil, tolerableQueueTime: Int64? = nil, autoSuspendTime: Int64? = nil, resourceType: String? = nil, dataEngineConfigPairs: [DataEngineConfigPair]? = nil, imageVersionName: String? = nil, mainClusterName: String? = nil, elasticSwitch: Bool? = nil, elasticLimit: Int64? = nil, sessionResourceTemplate: SessionResourceTemplate? = nil) {
            self.engineType = engineType
            self.dataEngineName = dataEngineName
            self.clusterType = clusterType
            self.mode = mode
            self.autoResume = autoResume
            self.minClusters = minClusters
            self.maxClusters = maxClusters
            self.defaultDataEngine = defaultDataEngine
            self.cidrBlock = cidrBlock
            self.message = message
            self.size = size
            self.payMode = payMode
            self.timeSpan = timeSpan
            self.timeUnit = timeUnit
            self.autoRenew = autoRenew
            self.tags = tags
            self.autoSuspend = autoSuspend
            self.crontabResumeSuspend = crontabResumeSuspend
            self.crontabResumeSuspendStrategy = crontabResumeSuspendStrategy
            self.engineExecType = engineExecType
            self.maxConcurrency = maxConcurrency
            self.tolerableQueueTime = tolerableQueueTime
            self.autoSuspendTime = autoSuspendTime
            self.resourceType = resourceType
            self.dataEngineConfigPairs = dataEngineConfigPairs
            self.imageVersionName = imageVersionName
            self.mainClusterName = mainClusterName
            self.elasticSwitch = elasticSwitch
            self.elasticLimit = elasticLimit
            self.sessionResourceTemplate = sessionResourceTemplate
        }

        enum CodingKeys: String, CodingKey {
            case engineType = "EngineType"
            case dataEngineName = "DataEngineName"
            case clusterType = "ClusterType"
            case mode = "Mode"
            case autoResume = "AutoResume"
            case minClusters = "MinClusters"
            case maxClusters = "MaxClusters"
            case defaultDataEngine = "DefaultDataEngine"
            case cidrBlock = "CidrBlock"
            case message = "Message"
            case size = "Size"
            case payMode = "PayMode"
            case timeSpan = "TimeSpan"
            case timeUnit = "TimeUnit"
            case autoRenew = "AutoRenew"
            case tags = "Tags"
            case autoSuspend = "AutoSuspend"
            case crontabResumeSuspend = "CrontabResumeSuspend"
            case crontabResumeSuspendStrategy = "CrontabResumeSuspendStrategy"
            case engineExecType = "EngineExecType"
            case maxConcurrency = "MaxConcurrency"
            case tolerableQueueTime = "TolerableQueueTime"
            case autoSuspendTime = "AutoSuspendTime"
            case resourceType = "ResourceType"
            case dataEngineConfigPairs = "DataEngineConfigPairs"
            case imageVersionName = "ImageVersionName"
            case mainClusterName = "MainClusterName"
            case elasticSwitch = "ElasticSwitch"
            case elasticLimit = "ElasticLimit"
            case sessionResourceTemplate = "SessionResourceTemplate"
        }
    }

    /// CreateDataEngine返回参数结构体
    public struct CreateDataEngineResponse: TCResponseModel {
        /// 虚拟引擎id
        public let dataEngineId: String

        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case dataEngineId = "DataEngineId"
            case requestId = "RequestId"
        }
    }

    /// 创建数据引擎.
    ///
    /// 为用户创建数据引擎
    @inlinable
    public func createDataEngine(_ input: CreateDataEngineRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDataEngineResponse> {
        self.client.execute(action: "CreateDataEngine", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 创建数据引擎.
    ///
    /// 为用户创建数据引擎
    @inlinable
    public func createDataEngine(_ input: CreateDataEngineRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateDataEngineResponse {
        try await self.client.execute(action: "CreateDataEngine", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 创建数据引擎.
    ///
    /// 为用户创建数据引擎
    @inlinable
    public func createDataEngine(engineType: String, dataEngineName: String, clusterType: String, mode: Int64, autoResume: Bool, minClusters: Int64? = nil, maxClusters: Int64? = nil, defaultDataEngine: Bool? = nil, cidrBlock: String? = nil, message: String? = nil, size: Int64? = nil, payMode: Int64? = nil, timeSpan: Int64? = nil, timeUnit: String? = nil, autoRenew: Int64? = nil, tags: [TagInfo]? = nil, autoSuspend: Bool? = nil, crontabResumeSuspend: Int64? = nil, crontabResumeSuspendStrategy: CrontabResumeSuspendStrategy? = nil, engineExecType: String? = nil, maxConcurrency: Int64? = nil, tolerableQueueTime: Int64? = nil, autoSuspendTime: Int64? = nil, resourceType: String? = nil, dataEngineConfigPairs: [DataEngineConfigPair]? = nil, imageVersionName: String? = nil, mainClusterName: String? = nil, elasticSwitch: Bool? = nil, elasticLimit: Int64? = nil, sessionResourceTemplate: SessionResourceTemplate? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDataEngineResponse> {
        self.createDataEngine(.init(engineType: engineType, dataEngineName: dataEngineName, clusterType: clusterType, mode: mode, autoResume: autoResume, minClusters: minClusters, maxClusters: maxClusters, defaultDataEngine: defaultDataEngine, cidrBlock: cidrBlock, message: message, size: size, payMode: payMode, timeSpan: timeSpan, timeUnit: timeUnit, autoRenew: autoRenew, tags: tags, autoSuspend: autoSuspend, crontabResumeSuspend: crontabResumeSuspend, crontabResumeSuspendStrategy: crontabResumeSuspendStrategy, engineExecType: engineExecType, maxConcurrency: maxConcurrency, tolerableQueueTime: tolerableQueueTime, autoSuspendTime: autoSuspendTime, resourceType: resourceType, dataEngineConfigPairs: dataEngineConfigPairs, imageVersionName: imageVersionName, mainClusterName: mainClusterName, elasticSwitch: elasticSwitch, elasticLimit: elasticLimit, sessionResourceTemplate: sessionResourceTemplate), region: region, logger: logger, on: eventLoop)
    }

    /// 创建数据引擎.
    ///
    /// 为用户创建数据引擎
    @inlinable
    public func createDataEngine(engineType: String, dataEngineName: String, clusterType: String, mode: Int64, autoResume: Bool, minClusters: Int64? = nil, maxClusters: Int64? = nil, defaultDataEngine: Bool? = nil, cidrBlock: String? = nil, message: String? = nil, size: Int64? = nil, payMode: Int64? = nil, timeSpan: Int64? = nil, timeUnit: String? = nil, autoRenew: Int64? = nil, tags: [TagInfo]? = nil, autoSuspend: Bool? = nil, crontabResumeSuspend: Int64? = nil, crontabResumeSuspendStrategy: CrontabResumeSuspendStrategy? = nil, engineExecType: String? = nil, maxConcurrency: Int64? = nil, tolerableQueueTime: Int64? = nil, autoSuspendTime: Int64? = nil, resourceType: String? = nil, dataEngineConfigPairs: [DataEngineConfigPair]? = nil, imageVersionName: String? = nil, mainClusterName: String? = nil, elasticSwitch: Bool? = nil, elasticLimit: Int64? = nil, sessionResourceTemplate: SessionResourceTemplate? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateDataEngineResponse {
        try await self.createDataEngine(.init(engineType: engineType, dataEngineName: dataEngineName, clusterType: clusterType, mode: mode, autoResume: autoResume, minClusters: minClusters, maxClusters: maxClusters, defaultDataEngine: defaultDataEngine, cidrBlock: cidrBlock, message: message, size: size, payMode: payMode, timeSpan: timeSpan, timeUnit: timeUnit, autoRenew: autoRenew, tags: tags, autoSuspend: autoSuspend, crontabResumeSuspend: crontabResumeSuspend, crontabResumeSuspendStrategy: crontabResumeSuspendStrategy, engineExecType: engineExecType, maxConcurrency: maxConcurrency, tolerableQueueTime: tolerableQueueTime, autoSuspendTime: autoSuspendTime, resourceType: resourceType, dataEngineConfigPairs: dataEngineConfigPairs, imageVersionName: imageVersionName, mainClusterName: mainClusterName, elasticSwitch: elasticSwitch, elasticLimit: elasticLimit, sessionResourceTemplate: sessionResourceTemplate), region: region, logger: logger, on: eventLoop)
    }
}
