//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

import Logging
import NIOCore
import TecoCore

extension Ssl {
    /// CreateCertificateByPackage请求参数结构体
    public struct CreateCertificateByPackageRequest: TCRequestModel {
        /// 证书产品PID。
        public let productPid: UInt64

        /// 要消耗的权益包ID。
        public let packageIds: [String]

        /// 证书域名数量。
        public let domainCount: String

        /// 多年期证书年限。
        public let period: UInt64

        /// 要续费的原证书ID（续费时填写）。
        public let oldCertificateId: String?

        /// 续费时CSR生成方式（original、upload、online）。
        public let renewGenCsrMethod: String?

        /// 续费时选择上传CSR时填写CSR。
        public let renewCsr: String?

        /// 续费证书CSR的算法类型。
        public let renewAlgorithmType: String?

        /// 续费证书CSR的算法参数。
        public let renewAlgorithmParam: String?

        /// 项目ID。
        public let projectId: UInt64?

        /// 标签。
        public let tags: [Tags]?

        /// 续费证书的私钥密码。
        public let renewKeyPass: String?

        /// 批量购买证书时预填写的域名。
        public let domainNames: String?

        /// 批量购买证书数量。
        public let certificateCount: UInt64?

        /// 预填写的管理人ID。
        public let managerId: UInt64?

        /// 预填写的公司ID。
        public let companyId: UInt64?

        /// 验证方式
        public let verifyType: String?

        public init(productPid: UInt64, packageIds: [String], domainCount: String, period: UInt64, oldCertificateId: String? = nil, renewGenCsrMethod: String? = nil, renewCsr: String? = nil, renewAlgorithmType: String? = nil, renewAlgorithmParam: String? = nil, projectId: UInt64? = nil, tags: [Tags]? = nil, renewKeyPass: String? = nil, domainNames: String? = nil, certificateCount: UInt64? = nil, managerId: UInt64? = nil, companyId: UInt64? = nil, verifyType: String? = nil) {
            self.productPid = productPid
            self.packageIds = packageIds
            self.domainCount = domainCount
            self.period = period
            self.oldCertificateId = oldCertificateId
            self.renewGenCsrMethod = renewGenCsrMethod
            self.renewCsr = renewCsr
            self.renewAlgorithmType = renewAlgorithmType
            self.renewAlgorithmParam = renewAlgorithmParam
            self.projectId = projectId
            self.tags = tags
            self.renewKeyPass = renewKeyPass
            self.domainNames = domainNames
            self.certificateCount = certificateCount
            self.managerId = managerId
            self.companyId = companyId
            self.verifyType = verifyType
        }

        enum CodingKeys: String, CodingKey {
            case productPid = "ProductPid"
            case packageIds = "PackageIds"
            case domainCount = "DomainCount"
            case period = "Period"
            case oldCertificateId = "OldCertificateId"
            case renewGenCsrMethod = "RenewGenCsrMethod"
            case renewCsr = "RenewCsr"
            case renewAlgorithmType = "RenewAlgorithmType"
            case renewAlgorithmParam = "RenewAlgorithmParam"
            case projectId = "ProjectId"
            case tags = "Tags"
            case renewKeyPass = "RenewKeyPass"
            case domainNames = "DomainNames"
            case certificateCount = "CertificateCount"
            case managerId = "ManagerId"
            case companyId = "CompanyId"
            case verifyType = "VerifyType"
        }
    }

    /// CreateCertificateByPackage返回参数结构体
    public struct CreateCertificateByPackageResponse: TCResponseModel {
        /// 证书ID。
        public let certificateId: String

        /// 批量购买证书时返回多个证书ID。
        public let certificateIds: [String]

        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case certificateId = "CertificateId"
            case certificateIds = "CertificateIds"
            case requestId = "RequestId"
        }
    }

    /// 使用权益点创建证书
    @inlinable
    public func createCertificateByPackage(_ input: CreateCertificateByPackageRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCertificateByPackageResponse> {
        self.client.execute(action: "CreateCertificateByPackage", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 使用权益点创建证书
    @inlinable
    public func createCertificateByPackage(_ input: CreateCertificateByPackageRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateCertificateByPackageResponse {
        try await self.client.execute(action: "CreateCertificateByPackage", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 使用权益点创建证书
    @inlinable
    public func createCertificateByPackage(productPid: UInt64, packageIds: [String], domainCount: String, period: UInt64, oldCertificateId: String? = nil, renewGenCsrMethod: String? = nil, renewCsr: String? = nil, renewAlgorithmType: String? = nil, renewAlgorithmParam: String? = nil, projectId: UInt64? = nil, tags: [Tags]? = nil, renewKeyPass: String? = nil, domainNames: String? = nil, certificateCount: UInt64? = nil, managerId: UInt64? = nil, companyId: UInt64? = nil, verifyType: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCertificateByPackageResponse> {
        self.createCertificateByPackage(.init(productPid: productPid, packageIds: packageIds, domainCount: domainCount, period: period, oldCertificateId: oldCertificateId, renewGenCsrMethod: renewGenCsrMethod, renewCsr: renewCsr, renewAlgorithmType: renewAlgorithmType, renewAlgorithmParam: renewAlgorithmParam, projectId: projectId, tags: tags, renewKeyPass: renewKeyPass, domainNames: domainNames, certificateCount: certificateCount, managerId: managerId, companyId: companyId, verifyType: verifyType), region: region, logger: logger, on: eventLoop)
    }

    /// 使用权益点创建证书
    @inlinable
    public func createCertificateByPackage(productPid: UInt64, packageIds: [String], domainCount: String, period: UInt64, oldCertificateId: String? = nil, renewGenCsrMethod: String? = nil, renewCsr: String? = nil, renewAlgorithmType: String? = nil, renewAlgorithmParam: String? = nil, projectId: UInt64? = nil, tags: [Tags]? = nil, renewKeyPass: String? = nil, domainNames: String? = nil, certificateCount: UInt64? = nil, managerId: UInt64? = nil, companyId: UInt64? = nil, verifyType: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateCertificateByPackageResponse {
        try await self.createCertificateByPackage(.init(productPid: productPid, packageIds: packageIds, domainCount: domainCount, period: period, oldCertificateId: oldCertificateId, renewGenCsrMethod: renewGenCsrMethod, renewCsr: renewCsr, renewAlgorithmType: renewAlgorithmType, renewAlgorithmParam: renewAlgorithmParam, projectId: projectId, tags: tags, renewKeyPass: renewKeyPass, domainNames: domainNames, certificateCount: certificateCount, managerId: managerId, companyId: companyId, verifyType: verifyType), region: region, logger: logger, on: eventLoop)
    }
}
