//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

import Logging
import NIOCore
import TecoCore

extension Ssl {
    /// CreateCertificate请求参数结构体
    public struct CreateCertificateRequest: TCRequestModel {
        /// 证书商品ID，3 = SecureSite 增强型企业版（EV Pro）， 4 = SecureSite 增强型（EV）， 5 = SecureSite 企业型专业版（OV Pro）， 6 = SecureSite 企业型（OV）， 7 = SecureSite 企业型（OV）通配符， 8 = Geotrust 增强型（EV）， 9 = Geotrust 企业型（OV）， 10 = Geotrust 企业型（OV）通配符， 11 = TrustAsia 域名型多域名 SSL 证书， 12 = TrustAsia 域名型（DV）通配符， 13 = TrustAsia 企业型通配符（OV）SSL 证书（D3）， 14 = TrustAsia 企业型（OV）SSL 证书（D3）， 15 = TrustAsia 企业型多域名 （OV）SSL 证书（D3）， 16 = TrustAsia 增强型 （EV）SSL 证书（D3）， 17 = TrustAsia 增强型多域名（EV）SSL 证书（D3）， 18 = GlobalSign 企业型（OV）SSL 证书， 19 = GlobalSign 企业型通配符 （OV）SSL 证书， 20 = GlobalSign 增强型 （EV）SSL 证书， 21 = TrustAsia 企业型通配符多域名（OV）SSL 证书（D3）， 22 = GlobalSign 企业型多域名（OV）SSL 证书， 23 = GlobalSign 企业型通配符多域名（OV）SSL 证书， 24 = GlobalSign 增强型多域名（EV）SSL 证书，25 = Wotrus 域名型证书，26 = Wotrus 域名型多域名证书，27 = Wotrus 域名型通配符证书，28 = Wotrus 企业型证书，29 = Wotrus 企业型多域名证书，30 = Wotrus 企业型通配符证书，31 = Wotrus 增强型证书，32 = Wotrus 增强型多域名证书，33 = DNSPod 国密域名型证书，34 = DNSPod 国密域名型多域名证书，35 = DNSPod 国密域名型通配符证书，37 = DNSPod 国密企业型证书，38 = DNSPod 国密企业型多域名证书，39 = DNSPod 国密企业型通配符证书，40 = DNSPod 国密增强型证书，41 = DNSPod 国密增强型多域名证书，42 = TrustAsia 域名型通配符多域名证书。
        public let productId: Int64

        /// 证书包含的域名数量
        public let domainNum: Int64

        /// 证书年限，当前只支持 1 年证书的购买
        public let timeSpan: Int64

        public init(productId: Int64, domainNum: Int64, timeSpan: Int64) {
            self.productId = productId
            self.domainNum = domainNum
            self.timeSpan = timeSpan
        }

        enum CodingKeys: String, CodingKey {
            case productId = "ProductId"
            case domainNum = "DomainNum"
            case timeSpan = "TimeSpan"
        }
    }

    /// CreateCertificate返回参数结构体
    public struct CreateCertificateResponse: TCResponseModel {
        /// 证书ID列表
        public let certificateIds: [String]

        /// 订单号列表
        public let dealIds: [String]

        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case certificateIds = "CertificateIds"
            case dealIds = "DealIds"
            case requestId = "RequestId"
        }
    }

    /// 创建付费证书
    ///
    /// 本接口（CreateCertificate）用于创建付费证书。
    @inlinable
    public func createCertificate(_ input: CreateCertificateRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCertificateResponse> {
        self.client.execute(action: "CreateCertificate", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 创建付费证书
    ///
    /// 本接口（CreateCertificate）用于创建付费证书。
    @inlinable
    public func createCertificate(_ input: CreateCertificateRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateCertificateResponse {
        try await self.client.execute(action: "CreateCertificate", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 创建付费证书
    ///
    /// 本接口（CreateCertificate）用于创建付费证书。
    @inlinable
    public func createCertificate(productId: Int64, domainNum: Int64, timeSpan: Int64, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCertificateResponse> {
        self.createCertificate(.init(productId: productId, domainNum: domainNum, timeSpan: timeSpan), region: region, logger: logger, on: eventLoop)
    }

    /// 创建付费证书
    ///
    /// 本接口（CreateCertificate）用于创建付费证书。
    @inlinable
    public func createCertificate(productId: Int64, domainNum: Int64, timeSpan: Int64, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateCertificateResponse {
        try await self.createCertificate(.init(productId: productId, domainNum: domainNum, timeSpan: timeSpan), region: region, logger: logger, on: eventLoop)
    }
}
