//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

import Logging
import NIOCore
import TecoCore

extension Iss {
    /// AddUserDevice请求参数结构体
    public struct AddUserDeviceRequest: TCRequest {
        /// 设备名称，仅支持中文、英文、数字、_、-，长度不超过32个字符；（设备名称无需全局唯一，可以重复）
        public let name: String

        /// 设备接入协议（1:RTMP,2:GB,3:GW）
        public let accessProtocol: Int64

        /// 设备类型，1:IPC,2:NVR；（若设备接入协议选择RTMP，则设备类型只能选择IPC）
        public let type: Int64

        /// 设备所属组织ID，从查询组织接口DescribeOrganization中获取
        public let organizationId: String

        /// 设备接入服务节点ID（从查询设备可用服务节点接口DescribeDeviceRegion中获取的Value字段）
        public let clusterId: String

        /// 设备流传输协议，1:UDP,2:TCP；(国标设备有效，不填写则默认UDP协议)
        public let transportProtocol: Int64?

        /// 设备密码（国标，网关设备必填，仅支持数字组合，长度为1-64个字符）
        public let password: String?

        /// 设备描述，仅支持中文、英文、数字、_、-，长度不超过128个字符
        public let description: String?

        /// 设备接入网关ID，从查询网关列表接口中ListGateways获取（仅网关接入需要）
        public let gatewayId: String?

        /// 网关接入协议类型（从查询网关接入协议接口DescribeGatewayProtocol中获取）1.海康SDK，2.大华SDK，3.宇视SDK，4.Onvif（仅网关接入需要）
        public let protocolType: Int64?

        /// 设备接入IP（仅网关接入需要）
        public let ip: String?

        /// 设备端口（仅网关接入需要）
        public let port: Int64?

        /// 设备用户名（仅网关接入需要）
        public let username: String?

        public init(name: String, accessProtocol: Int64, type: Int64, organizationId: String, clusterId: String, transportProtocol: Int64? = nil, password: String? = nil, description: String? = nil, gatewayId: String? = nil, protocolType: Int64? = nil, ip: String? = nil, port: Int64? = nil, username: String? = nil) {
            self.name = name
            self.accessProtocol = accessProtocol
            self.type = type
            self.organizationId = organizationId
            self.clusterId = clusterId
            self.transportProtocol = transportProtocol
            self.password = password
            self.description = description
            self.gatewayId = gatewayId
            self.protocolType = protocolType
            self.ip = ip
            self.port = port
            self.username = username
        }

        enum CodingKeys: String, CodingKey {
            case name = "Name"
            case accessProtocol = "AccessProtocol"
            case type = "Type"
            case organizationId = "OrganizationId"
            case clusterId = "ClusterId"
            case transportProtocol = "TransportProtocol"
            case password = "Password"
            case description = "Description"
            case gatewayId = "GatewayId"
            case protocolType = "ProtocolType"
            case ip = "Ip"
            case port = "Port"
            case username = "Username"
        }
    }

    /// AddUserDevice返回参数结构体
    public struct AddUserDeviceResponse: TCResponse {
        /// 增加设备返回数据
        public let data: AddDeviceData

        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case data = "Data"
            case requestId = "RequestId"
        }
    }

    /// 新增设备
    ///
    /// 用于新增单个设备。添加设备之后，可根据返回结果到设备上进行配置，配置后等待设备注册/推流。
    @inlinable
    public func addUserDevice(_ input: AddUserDeviceRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AddUserDeviceResponse> {
        self.client.execute(action: "AddUserDevice", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 新增设备
    ///
    /// 用于新增单个设备。添加设备之后，可根据返回结果到设备上进行配置，配置后等待设备注册/推流。
    @inlinable
    public func addUserDevice(_ input: AddUserDeviceRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> AddUserDeviceResponse {
        try await self.client.execute(action: "AddUserDevice", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 新增设备
    ///
    /// 用于新增单个设备。添加设备之后，可根据返回结果到设备上进行配置，配置后等待设备注册/推流。
    @inlinable
    public func addUserDevice(name: String, accessProtocol: Int64, type: Int64, organizationId: String, clusterId: String, transportProtocol: Int64? = nil, password: String? = nil, description: String? = nil, gatewayId: String? = nil, protocolType: Int64? = nil, ip: String? = nil, port: Int64? = nil, username: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AddUserDeviceResponse> {
        self.addUserDevice(.init(name: name, accessProtocol: accessProtocol, type: type, organizationId: organizationId, clusterId: clusterId, transportProtocol: transportProtocol, password: password, description: description, gatewayId: gatewayId, protocolType: protocolType, ip: ip, port: port, username: username), region: region, logger: logger, on: eventLoop)
    }

    /// 新增设备
    ///
    /// 用于新增单个设备。添加设备之后，可根据返回结果到设备上进行配置，配置后等待设备注册/推流。
    @inlinable
    public func addUserDevice(name: String, accessProtocol: Int64, type: Int64, organizationId: String, clusterId: String, transportProtocol: Int64? = nil, password: String? = nil, description: String? = nil, gatewayId: String? = nil, protocolType: Int64? = nil, ip: String? = nil, port: Int64? = nil, username: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> AddUserDeviceResponse {
        try await self.addUserDevice(.init(name: name, accessProtocol: accessProtocol, type: type, organizationId: organizationId, clusterId: clusterId, transportProtocol: transportProtocol, password: password, description: description, gatewayId: gatewayId, protocolType: protocolType, ip: ip, port: port, username: username), region: region, logger: logger, on: eventLoop)
    }
}
