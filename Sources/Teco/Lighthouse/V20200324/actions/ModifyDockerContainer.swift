//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by TecoServiceGenerator.
// DO NOT EDIT.

import Logging
import NIOCore
import TecoCore

extension Lighthouse {
    /// ModifyDockerContainer请求参数结构体
    public struct ModifyDockerContainerRequest: TCRequestModel {
        /// 实例ID。
        public let instanceId: String

        /// 容器ID。
        public let containerId: String

        /// 环境变量列表
        public let envs: [ContainerEnv]?

        /// 容器端口主机端口映射列表
        public let publishPorts: [DockerContainerPublishPort]?

        /// 容器加载本地卷列表
        public let volumes: [DockerContainerVolume]?

        /// 运行的命令
        public let command: String?

        /// 容器重启策略，对应docker "--restart"参数。
        ///
        /// 枚举值:
        /// no: 不自动重启。默认策略。
        /// on-failure[:max-retries]: 当容器退出码非0时重启容器。使用max-retries限制重启次数，比如on-failure:10，限制最多重启10次。
        /// always: 只要容器退出就重启。
        /// unless-stopped: 始终重新启动容器，包括在守护进程启动时，除非容器在 Docker 守护进程停止之前进入停止状态。
        public let restartPolicy: String?

        public init(instanceId: String, containerId: String, envs: [ContainerEnv]? = nil, publishPorts: [DockerContainerPublishPort]? = nil, volumes: [DockerContainerVolume]? = nil, command: String? = nil, restartPolicy: String? = nil) {
            self.instanceId = instanceId
            self.containerId = containerId
            self.envs = envs
            self.publishPorts = publishPorts
            self.volumes = volumes
            self.command = command
            self.restartPolicy = restartPolicy
        }

        enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case containerId = "ContainerId"
            case envs = "Envs"
            case publishPorts = "PublishPorts"
            case volumes = "Volumes"
            case command = "Command"
            case restartPolicy = "RestartPolicy"
        }
    }

    /// ModifyDockerContainer返回参数结构体
    public struct ModifyDockerContainerResponse: TCResponseModel {
        /// Docker活动ID。
        public let dockerActivityId: String

        /// 唯一请求 ID，每次请求都会返回。定位问题时需要提供该次请求的 RequestId。
        public let requestId: String

        enum CodingKeys: String, CodingKey {
            case dockerActivityId = "DockerActivityId"
            case requestId = "RequestId"
        }
    }

    /// 修改实例内的Docker容器
    ///
    /// 修改实例内的Docker容器，之后可以通过返回的ActivityId调用DescribeDockerActivities接口查询重建情况。
    /// 请注意：本接口会重新创建并运行实例内的Docker容器。
    @inlinable
    public func modifyDockerContainer(_ input: ModifyDockerContainerRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ModifyDockerContainerResponse> {
        self.client.execute(action: "ModifyDockerContainer", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// 修改实例内的Docker容器
    ///
    /// 修改实例内的Docker容器，之后可以通过返回的ActivityId调用DescribeDockerActivities接口查询重建情况。
    /// 请注意：本接口会重新创建并运行实例内的Docker容器。
    @inlinable
    public func modifyDockerContainer(_ input: ModifyDockerContainerRequest, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ModifyDockerContainerResponse {
        try await self.client.execute(action: "ModifyDockerContainer", region: region, serviceConfig: self.config, input: input, logger: logger, on: eventLoop).get()
    }

    /// 修改实例内的Docker容器
    ///
    /// 修改实例内的Docker容器，之后可以通过返回的ActivityId调用DescribeDockerActivities接口查询重建情况。
    /// 请注意：本接口会重新创建并运行实例内的Docker容器。
    @inlinable
    public func modifyDockerContainer(instanceId: String, containerId: String, envs: [ContainerEnv]? = nil, publishPorts: [DockerContainerPublishPort]? = nil, volumes: [DockerContainerVolume]? = nil, command: String? = nil, restartPolicy: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ModifyDockerContainerResponse> {
        self.modifyDockerContainer(.init(instanceId: instanceId, containerId: containerId, envs: envs, publishPorts: publishPorts, volumes: volumes, command: command, restartPolicy: restartPolicy), region: region, logger: logger, on: eventLoop)
    }

    /// 修改实例内的Docker容器
    ///
    /// 修改实例内的Docker容器，之后可以通过返回的ActivityId调用DescribeDockerActivities接口查询重建情况。
    /// 请注意：本接口会重新创建并运行实例内的Docker容器。
    @inlinable
    public func modifyDockerContainer(instanceId: String, containerId: String, envs: [ContainerEnv]? = nil, publishPorts: [DockerContainerPublishPort]? = nil, volumes: [DockerContainerVolume]? = nil, command: String? = nil, restartPolicy: String? = nil, region: TCRegion? = nil, logger: Logger = TCClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ModifyDockerContainerResponse {
        try await self.modifyDockerContainer(.init(instanceId: instanceId, containerId: containerId, envs: envs, publishPorts: publishPorts, volumes: volumes, command: command, restartPolicy: restartPolicy), region: region, logger: logger, on: eventLoop)
    }
}
